<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html><head>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1"><meta name="GENERATOR" content="TtH 2.70">
                 
<title>Linux IP Networking: A Guide to the Implementation and Modification
of the Linux Protocol Stack</title>

</head><body><h1 align="center"><br> <b>Linux IP Networking<br> <font size="-0">A
Guide to the Implementation and Modification of the Linux Protocol
Stack</font></b> </h1>

<h3 align="center"><i>Glenn Herrin</i>
</h3>

<center><b>TR 00-04</b>
<p><a href="http://www.cs.unh.edu/">Department of Computer Science</a>
<br><a href="http://www.unh.edu/">University of New Hampshire</a>
<br><a href="http://www.cs.unh.edu/cnrg/people/gherrin/www.unh.edu"></a>
</p></center>

<h3 align="center"><i>May 31, 2000 </i></h3>


<p>
<font size="+2"><b>Abstract</b></font>

</p><p>
This document is a guide to understanding how the Linux kernel 
(version&nbsp;2.2.14 specifically) implements networking protocols, 
focused primarily on the Internet Protocol (IP).  It is intended as a 
complete reference for experimenters with overviews, walk-throughs, 
source code explanations, and examples.  The first part contains an 
in-depth examination of the code, data structures, and functionality 
involved with networking.  There are chapters on initialization, 
connections and sockets, and receiving, transmitting, and forwarding 
packets.  The second part contains detailed instructions for modifiying 
the kernel source code and installing new modules.  There are chapters 
on kernel installation, modules, the <i>proc</i> file system, and a complete example.

</p><p>

</p><h1>Contents </h1><a href="#tth_chAp1">1&nbsp; Introduction</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc1.1">1.1&nbsp; Background</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc1.2">1.2&nbsp; Document Conventions</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc1.3">1.3&nbsp; Sample Network Example</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc1.4">1.4&nbsp; Copyright, License, and Disclaimer</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc1.5">1.5&nbsp; Acknowledgements</a><br>
<a href="#tth_chAp2">2&nbsp; Message Traffic Overview</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.1">2.1&nbsp; The Network Traffic Path</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.2">2.2&nbsp; The Protocol Stack</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.3">2.3&nbsp; Packet Structure</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.4">2.4&nbsp; Internet Routing</a><br>
<a href="#tth_chAp3">3&nbsp; Network Initialization</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.1">3.1&nbsp; Overview</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.2">3.2&nbsp; Startup</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.2.1">3.2.1&nbsp; The Network Initialization Script</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.2.2">3.2.2&nbsp; <i>ifconfig</i></a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.2.3">3.2.3&nbsp; <i>route</i></a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.2.4">3.2.4&nbsp; Dynamic Routing Programs</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.3">3.3&nbsp; Examples</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.3.1">3.3.1&nbsp; Home Computer</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.3.2">3.3.2&nbsp; Host Computer on a LAN</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.3.3">3.3.3&nbsp; Network Routing Computer</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.4">3.4&nbsp; Linux and Network Program Functions</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.4.1">3.4.1&nbsp; <i>ifconfig</i></a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.4.2">3.4.2&nbsp; <i>route</i></a><br>
<a href="#tth_chAp4">4&nbsp; Connections</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.1">4.1&nbsp; Overview</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.2">4.2&nbsp; Socket Structures</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.3">4.3&nbsp; Sockets and Routing</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.4">4.4&nbsp; Connection Processes</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.4.1">4.4.1&nbsp; Establishing Connections</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.4.2">4.4.2&nbsp; Socket Call Walk-Through</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.4.3">4.4.3&nbsp; Connect Call Walk-Through</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.4.4">4.4.4&nbsp; Closing Connections</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.4.5">4.4.5&nbsp; Close Walk-Through</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.5">4.5&nbsp; Linux Functions</a><br>
<a href="#tth_chAp5">5&nbsp; Sending Messages</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.1">5.1&nbsp; Overview</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.2">5.2&nbsp; Sending Walk-Through</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.2.1">5.2.1&nbsp; Writing to a Socket</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.2.2">5.2.2&nbsp; Creating a Packet with UDP</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.2.3">5.2.3&nbsp; Creating a Packet with TCP</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.2.4">5.2.4&nbsp; Wrapping a Packet in IP</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.2.5">5.2.5&nbsp; Transmitting a Packet</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.3">5.3&nbsp; Linux Functions</a><br>
<a href="#tth_chAp6">6&nbsp; Receiving Messages</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.1">6.1&nbsp; Overview</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.2">6.2&nbsp; Receiving Walk-Through</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.2.1">6.2.1&nbsp; Reading from a Socket (Part I)</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.2.2">6.2.2&nbsp; Receiving a Packet</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.2.3">6.2.3&nbsp; Running the Network ``Bottom Half''</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.2.4">6.2.4&nbsp; Unwrapping a Packet in IP</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.2.5">6.2.5&nbsp; Accepting a Packet in UDP</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.2.6">6.2.6&nbsp; Accepting a Packet in TCP</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.2.7">6.2.7&nbsp; Reading from a Socket (Part II)</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.3">6.3&nbsp; Linux Functions</a><br>
<a href="#tth_chAp7">7&nbsp; IP Forwarding</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.1">7.1&nbsp; Overview</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.2">7.2&nbsp; IP Forward Walk-Through</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.2.1">7.2.1&nbsp; Receiving a Packet</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.2.2">7.2.2&nbsp; Running the Network ``Bottom Half''</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.2.3">7.2.3&nbsp; Examining a Packet in IP</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.2.4">7.2.4&nbsp; Forwarding a Packet in IP</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.2.5">7.2.5&nbsp; Transmitting a Packet</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.3">7.3&nbsp; Linux Functions</a><br>
<a href="#tth_chAp8">8&nbsp; Basic Internet Protocol Routing</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.1">8.1&nbsp; Overview</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.2">8.2&nbsp; Routing Tables</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.2.1">8.2.1&nbsp; The Neighbor Table</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.2.2">8.2.2&nbsp; The Forwarding Information Base</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.2.3">8.2.3&nbsp; The Routing Cache</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.2.4">8.2.4&nbsp; Updating Routing Information</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.3">8.3&nbsp; Linux Functions</a><br>
<a href="#tth_chAp9">9&nbsp; Dynamic Routing with <i>routed</i></a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.1">9.1&nbsp; Overview</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.2">9.2&nbsp; How <i>routed</i> Works</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.2.1">9.2.1&nbsp; Data Structures</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.2.2">9.2.2&nbsp; Initialization</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.2.3">9.2.3&nbsp; Normal Operations</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.3">9.3&nbsp; <i>routed</i> Functions</a><br>
<a href="#tth_chAp10">10&nbsp; Editing Linux Source Code</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc10.1">10.1&nbsp; The Linux Source Tree</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc10.2">10.2&nbsp; Using EMACS Tags</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc10.2.1">10.2.1&nbsp; Referencing with TAGS</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc10.2.2">10.2.2&nbsp; Constructing TAGS files</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc10.3">10.3&nbsp; Using vi tags</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc10.4">10.4&nbsp; Rebuilding the Kernel</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc10.5">10.5&nbsp; Patching the Kernel Source</a><br>
<a href="#tth_chAp11">11&nbsp; Linux Modules</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc11.1">11.1&nbsp; Overview</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc11.2">11.2&nbsp; Writing, Installing, and Removing Modules</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc11.2.1">11.2.1&nbsp; Writing Modules</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc11.2.2">11.2.2&nbsp; Installing and Removing Modules</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc11.3">11.3&nbsp; Example</a><br>
<a href="#tth_chAp12">12&nbsp; The <i>proc</i> File System</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc12.1">12.1&nbsp; Overview</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc12.2">12.2&nbsp; Network <i>proc</i> Files</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc12.3">12.3&nbsp; Registering <i>proc</i> Files</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc12.3.1">12.3.1&nbsp; Formatting a Function to Provide Information</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc12.3.2">12.3.2&nbsp; Building a <i>proc</i> Entry</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc12.3.3">12.3.3&nbsp; Registering a <i>proc</i> Entry</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc12.3.4">12.3.4&nbsp; Unregistering a <i>proc</i> Entry</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc12.4">12.4&nbsp; Example</a><br>
<a href="#tth_chAp13">13&nbsp; Example - Packet Dropper</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc13.1">13.1&nbsp; Overview</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc13.2">13.2&nbsp; Considerations</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc13.3">13.3&nbsp; Experimental Systems and Benchmarks</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc13.4">13.4&nbsp; Results and Preliminary Analysis</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc13.4.1">13.4.1&nbsp; Standard Kernel</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc13.4.2">13.4.2&nbsp; Modified Kernel Dropping Packets</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc13.4.3">13.4.3&nbsp; Preliminary Analysis</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc13.5">13.5&nbsp; Code</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc13.5.1">13.5.1&nbsp; Kernel</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc13.5.2">13.5.2&nbsp; Module</a><br>
<a href="#tth_chAp14">14&nbsp; Additional Resources</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc14.1">14.1&nbsp; Internet Sites</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc14.2">14.2&nbsp; Books</a><br>
<a href="#tth_chAp15">15&nbsp; Acronyms</a><br>
 
<p>
      </p><h1><a name="tth_chAp1">
Chapter 1     </a><br>Introduction</h1>
<a name="intro">
</a>
This is version 1.0 of this document, dated May 31, 2000, referencing the Linux kernel version 2.2.14.

<p>
        </p><h2><a name="tth_sEc1.1">
1.1</a>&nbsp;&nbsp;Background</h2>
Linux is becoming more and more popular as an alternative operating 
system.  Since it is freely available to everyone as part of the open 
source movement, literally thousands of programmers are constantly 
working on the code to implement new features, improve existing ones, 
and fix bugs and inefficiencies in the code.  There are many sources for
 learning more about Linux, from the source code itself (downloadable 
from the Internet) to books to ``HOW-TOs'' and message boards maintained
 on many different subjects.

<p>
This document is an effort to bring together many of these sources into 
one coherent reference on and guide to modifying the networking code 
within the Linux kernel.  It presents the internal workings on four 
levels: a general overview, more specific examinations of network 
activities, detailed function walk-throughs, and references to the 
actual code and data structures.  It is designed to provide as much or 
as little detail as the reader desires.  This guide was written 
specifically about the Linux 2.2.14 kernel (which has already been 
superseded by 2.2.15) and many of the examples come from the Red Hat 6.1
 distribution; hopefully the information provided is general enough that
 it will still apply across distributions and new kernels.  It also 
focuses almost exclusively on TCP/UDP, IP, and Ethernet - which are the 
most common but by no means the only networking protocols available for 
Linux platforms.

</p><p>
As a reference for kernel programmers, this document includes 
information and pointers on editing and recompiling the kernel, writing 
and installing modules, and working with the <i>/proc</i> file system.  
 It also presents an example of a program that drops packets for a 
selected host, along with analysis of the results.  Between the 
descriptions and the examples, this should answer most questions about 
how Linux performs networking operations and how you can modify it to 
suit your own purposes.

</p><p>
This project began in a Computer Science Department networking lab at 
the University of New Hampshire as an effort to institute changes in the
 Linux kernel to experiment with different routing algorithms.  It 
quickly became apparent that blindly hacking the kernel was not a good 
idea, so this document was born as a research record and a reference for
 future programmers.  Finally it became large enough (and hopefully 
useful enough) that we decided to generalize it, formalize it, and 
release it for public consumption.

</p><p>
As a final note, Linux is an ever-changing system and truly mastering 
it, if such a thing is even possible, would take far more time than has 
been spent putting this reference together.  If you notice any 
misstatements, omissions, glaring errors, or even typos (!) within this 
document, please contact the person who is currently maintaining it.  
The goal of this project has been to create a freely available and 
useful reference for Linux programmers.

</p><p>
        </p><h2><a name="tth_sEc1.2">
1.2</a>&nbsp;&nbsp;Document Conventions</h2>
It is assumed that the reader understands the C programming language and
 is acquainted with common network protocols.  This is not vital for the
 more general information but the details within this document are 
intended for experienced programmers and may be incomprehensible to 
casual Linux users.

<p>
Almost all of the code presented requires superuser access to implement.
  Some of the examples can create security holes where none previously 
existed; programmers should be careful to restore their systems to a 
normal state after experimenting with the kernel.

</p><p>
File references and program names are written in a <i>slanted</i> font.

</p><p>
Code, command line entries, and machine names are written in a <tt>typewriter</tt> font.

</p><p>
Generic entries or variables (such as an output filename) and comments are written in an <i>italic</i> font.

</p><p>
        </p><h2><a name="tth_sEc1.3">
1.3</a>&nbsp;&nbsp;Sample Network Example</h2>
There are numerous examples in this document that help clarify the 
presented material.  For the sake of consistency and familiarity, most 
of them reference the sample network shown in Figure&nbsp;<a href="#i_example">1.1</a>.

<p><a name="tth_fIg1.1">
</a> 
<img src="linux-net_files/i_example.gif" alt="i_example.gif"><br>

 </p><center>Figure 1.1: Sample network structure.</center>
<a name="i_example">
</a>
<p>
</p><p>
This network represents the computer system at a fictional unnamed 
University (U!).  It has a router connected to the Internet at large (<tt>chrysler</tt>).  That machine is connected (through the <tt>jeep</tt> interface) to the campus-wide network, <tt>u.edu</tt>, consisting of computers named for Chrysler owned car companies (<tt>dodge</tt>, <tt>eagle</tt>, etc.).  There is also a LAN subnet for the computer science department, <tt>cs.u.edu</tt>, whose hosts are named after Dodge vehicle models (<tt>stealth</tt>, <tt>neon</tt>, etc.).  They are connected to the campus network by the <tt>dodge/viper</tt> computer.  Both the <tt>u.edu</tt> and <tt>cs.u.edu</tt> networks use Ethernet hardware and protocols.

</p><p>
This is obviously not a real network.  The IP addresses are all taken 
from the block reserved for class B private networks (that are not 
guaranteed to be unique).  Most real class B networks would have many 
more computers, and a network with only eight computers would probably 
not have a subnet.  The connection to the Internet (through <tt>chrysler</tt>)
 would usually be via a T1 or T3 line, and that router would probably be
 a ``real'' router (i.e. a Cisco Systems hardware router) rather than a 
computer with two network cards.  However, this example is realistic 
enough to serve its purpose: to illustrate the the Linux network 
implementation and the interactions between hosts, subnets, and 
networks.

</p><p>
        </p><h2><a name="tth_sEc1.4">
1.4</a>&nbsp;&nbsp;Copyright, License, and Disclaimer</h2>

<p>
Copyright (c) 2000 by Glenn Herrin.  This document may be freely 
reproduced in whole or in part provided credit is given to the author 
with a line similar to the following:

</p><blockquote>
<tt>Copied from Linux IP Networking, available at <i><a href="http://www.cs.unh.edu/cnrg/gherrin">http://www.cs.unh.edu/cnrg/gherrin</a></i></tt>.
</blockquote>

(The visibility of the credit should be proportional to the amount of 
the document reproduced!)  Commercial redistribution is permitted and 
encouraged.  All modifications of this document, including translations,
 anthologies, and partial documents, must meet the following 
requirements: 

<ol type="1">

<li> Modified versions must be labeled as such. 

</li><li> The person making the modifications must be identified.

</li><li> Acknowledgement of the original author must be retained.

</li><li> The location of the original unmodified document be identified.

</li><li> The original author's name may not be used to assert or imply 
endorsement of the resulting document without the original author's 
permission. 
</li></ol>
<p>
Please note any modifications including deletions.

</p><p>
This is a variation (changes are intentional) of the Linux Documentaion Project (LDP) License available at:

</p><blockquote>
<i><a href="http://www.linuxdoc.org/COPYRIGHT.html">http://www.linuxdoc.org/COPYRIGHT.html</a></i>
</blockquote>
This document is not currently part of the LDP, but it may be submitted in the future.

<p>
This document is distributed in the hope that it will be useful but (of 
course)without any given or implied warranty of fitness for any purpose 
whatsoever.  Use it at your own risk.

</p><p>
        </p><h2><a name="tth_sEc1.5">
1.5</a>&nbsp;&nbsp;Acknowledgements</h2>
I wrote this document as part of my Master's project for the Computer 
Science Department of the University of New Hampshire.  I would like to 
thank Professor Pilar de la Torre for setting up the project and 
Professor Radim Bartos for being both a sponsor and my advisor - giving 
me numerous pointers, much encouragement, and a set of computers on 
which to experiment.  I would also like to credit the United States 
Army, which has been my home for 11 years and paid for my attendance at 
UNH.

<p>
Glenn Herrin<br>
Major, United States Army<br>
Primary Documenter and Researcher, Version 1.0<br>
gherrin@cs.unh.edu

</p><p>
      </p><h1><a name="tth_chAp2">
Chapter 2     </a><br>Message Traffic Overview</h1>
<a name="overview">
</a>

<p>
This chapter presents an overview of the entire Linux messaging system. 
 It provides a discussion of configurations, introduces the data 
structures involved, and describes the basics of IP routing.

</p><p>
        </p><h2><a name="tth_sEc2.1">
2.1</a>&nbsp;&nbsp;The Network Traffic Path</h2>
The Internet Protocol (IP) is the heart of the Linux messaging system.  
While Linux (more or less) strictly adheres to the layering concept - 
and it is possible to use a different protocol (like ATM) - IP is almost
 always the nexus through which packets flow.  The IP implementation of 
the network layer performs routing and forwarding as well as 
encapsulating data.  See Figure&nbsp;<a href="#o_path">2.1</a> for a simplified diagram of how network packets move through the Linux kernel.

<p><a name="tth_fIg2.1">
</a> 
<img src="linux-net_files/o_path.gif" alt="o_path.gif"><br>

 </p><center>Figure 2.1: Abstraction of the Linux message traffic path.</center>
<a name="o_path">
</a>
<p>
</p><p>
When an application generates traffic, it sends packets through sockets 
to a transport layer (TCP or UDP) and then on to the network layer (IP).
  In the IP layer, the kernel looks up the route to the host in either 
the routing cache or its Forwarding Information Base (FIB).  If the 
packet is for another computer, the kernel addresses it and then sends 
it to a link layer output interface (typically an Ethernet device) which
 ultimately sends the packet out over the physical medium.

</p><p>
When a packet arrives over the medium, the input interface receives it 
and checks to see if the packet is indeed for the host computer.  If so,
 it sends the packet up to the IP layer, which looks up the route to the
 packet's destination.  If the packet has to be forwarded to another 
computer, the IP layer sends it back down to an output interface.  If 
the packet is for an application, it sends it up through the transport 
layer and sockets for the application to read when it is ready.

</p><p>
Along the way, each socket and protocol performs various checks and 
formatting functions, detailed in later chapters.  The entire process is
 implemented with references and jump tables that isolate each protocol,
 most of which are set up during initialization when the computer boots.
  See Chapter&nbsp;<a href="#initialization">3</a> for details of the initialization process.

</p><p>
        </p><h2><a name="tth_sEc2.2">
2.2</a>&nbsp;&nbsp;The Protocol Stack</h2>
Network devices form the bottom layer of the protocol stack; they use a 
link layer protocol (usually Ethernet) to communicate with other devices
 to send and receive traffic.  Input interfaces copy packets from a 
medium, perform some error checks, and then forward them to the network 
layer.  Output interfaces receive packets from the network layer, 
perform some error checks, and then send them out over the medium.

<p>
IP is the standard network layer protocol.  It checks incoming packets 
to see if they are for the host computer or if they need to be 
forwarded.  It defragments packets if necessary and delivers them to the
 transport protocols.  It maintains a database of routes for outgoing 
packets; it addresses and fragments them if necessary before sending 
them down to the link layer.

</p><p>
TCP and UDP are the most common transport layer protocols.  UDP simply 
provides a framework for addressing packets to ports within a computer, 
while TCP allows more complex connection based operations, including 
recovery mechanisms for packet loss and traffic management 
implementations.  Either one copies the packet's payload between user 
and kernel space.  However, both are just part of the intermediate layer
 between the applications and the network.

</p><p>
IP Specific INET Sockets are the data elements and implementations of 
generic sockets.  They have associated queues and code that executes 
socket operations such as reading, writing, and making connections.  
They act as the intermediary between an application's generic socket and
 the transport layer protocol.

</p><p>
Generic BSD Sockets are more abstract structures that contain INET 
sockets.  Applications read from and write to BSD sockets; the BSD 
sockets translate the operations into INET socket operations.  See 
Chapter&nbsp;<a href="#connect">4</a> for more on sockets.

</p><p>
Applications, run in user space, form the top level of the protocol 
stack; they can be as simple as two-way chat connection or as complex as
 the Routing Information Protocol (RIP - see Chapter&nbsp;<a href="#dyn_route">9</a>).

</p><p>
        </p><h2><a name="tth_sEc2.3">
2.3</a>&nbsp;&nbsp;Packet Structure</h2>
The key to maintaining the strict layering of protocols without wasting 
time copying parameters and payloads back and forth is the common packet
 data structure (a socket buffer, or <tt>sk_buff</tt> - Figure&nbsp;<a href="#o_skbuff">2.2</a>).
  Throughout all of the various function calls as the data makes it way 
through the protocols, the payload data is copied only twice; once from 
user to kernel space and once from kernel space to output medium (for an
 outbound packet).

<p><a name="tth_fIg2.2">
</a> 
<img src="linux-net_files/o_skbuff.gif" alt="o_skbuff.gif"><br>

 </p><center>Figure 2.2: Packet (<tt>sk_buff</tt>) structure.</center>
<a name="o_skbuff">
</a>
<p>
</p><p>
This structure contains pointers to all of the information about a 
packet - its socket, device, route, data locations, etc.  Transport 
protocols create these packet structures from output buffers, while 
device drivers create them for incoming data.  Each layer then fills in 
the information that it needs as it processes the packet.  All of the 
protocols - transport (TCP/UDP), internet (IP), and link level 
(Ethernet) - use the same socket buffer.

</p><p>
        </p><h2><a name="tth_sEc2.4">
2.4</a>&nbsp;&nbsp;Internet Routing</h2>
The IP layer handles routing between computers.  It keeps two data 
structures; a Forwarding Information Base (FIB) that keeps track of all 
of the details for every known route, and a faster routing cache for 
destinations that are currently in use.  (There is also a third 
structure - the neighbor table - that keeps track of computers that are 
physically connected to a host.) 

<p>
The FIB is the primary routing reference; it contains up to 32 zones 
(one for each bit in an IP address) and entries for every known 
destination.  Each zone contains entries for networks or hosts that can 
be uniquely identified by a certain number of bits - a network with a 
netmask of 255.0.0.0 has 8 significant bits and would be in zone 8, 
while a network with a netmask of 255.255.255.0 has 24 significant bits 
and would be in zone 24.  When IP needs a route, it begins with the most
 specific zones and searches the entire table until it finds a match 
(there should always be at least one default entry).  The file <i>/proc/net/route</i> has the contents of the FIB.

</p><p>
The routing cache is a hash table that IP uses to actually route 
packets.  It contains up to 256 chains of current routing entries, with 
each entry's position determined by a hash function.  When a host needs 
to send a packet, IP looks for an entry in the routing cache.  If there 
is none, it finds the appropriate route in the FIB and inserts a new 
entry into the cache.  (This entry is what the various protocols use to 
route, not the FIB entry.)  The entries remain in the cache as long as 
they are being used; if there is no traffic for a destination, the entry
 times out and IP deletes it.  The file <i>/proc/net/rt_cache</i> has the contents of the routing cache.

</p><p>
These tables perform all the routing on a normal system.  Even other 
protocols (such as RIP) use the same structures; they just modify the 
existing tables within the kernel using the <tt>ioctl()</tt> function.  See Chapter&nbsp;<a href="#routing">8</a> for routing details.

</p><p>
      </p><h1><a name="tth_chAp3">
Chapter 3     </a><br>Network Initialization</h1>
<a name="initialization">
</a>

<p>
This chapter presents network initialization on startup.  It provides an
 overview of what happens when the Linux operating system boots, shows 
how the kernel and supporting programs <i>ifconfig</i> and <i>route</i> 
establish network links, shows the differences between several example 
configurations, and summarizes the implementation code within the kernel
 and network programs.

</p><p>
        </p><h2><a name="tth_sEc3.1">
3.1</a>&nbsp;&nbsp;Overview</h2>
Linux initializes routing tables on startup only if a computer is 
configured for networking.  (Almost all Linux machines do implement 
networking, even stand-alone machines, if only to use the loopback 
device.)  When the kernel finishes loading itself, it runs a set of 
common but system specific utility programs and reads configuration 
files, several of which establish the computer's networking 
capabilities.  These determine its own address, initialize its 
interfaces (such as Ethernet cards), and add critical and known static 
routes (such as one to a router that connects it with the rest of the 
Internet).  If the computer is itself a router, it may also execute a 
program that allows it to update its routing tables dynamically (but 
this is NOT run on most hosts).

<p>
The entire configuration process can be static or dynamic.  If addresses
 and names never (or infrequently) change, the system administrator must
 define options and variables in files when setting up the system.  In a
 more mutable environment, a host will use a protocol like the Dynamic 
Hardware Configuration Protocol (DHCP) to ask for an address, router, 
and DNS server information with which to configure itself when it boots.
  (In fact, in either case, the administrator will almost always use a 
GUI interface - like Red Hat's Control Panel - which automatically 
writes the configuration files shown below.)

</p><p>
An important point to note is that while most computers running Linux 
start up the same way, the programs and their locations are not by any 
means standardized; they may vary widely depending on distribution, 
security concerns, or whim of the system administrator.  This chapter 
presents as generic a description as possible but assumes a Red Hat 
Linux 6.1 distribution and a generally static network environment.

</p><p>
        </p><h2><a name="tth_sEc3.2">
3.2</a>&nbsp;&nbsp;Startup</h2>
When Linux boots as an operating system, it loads its image from the 
disk into memory, unpacks it, and establishes itself by installing the 
file systems and memory management and other key systems.  As the 
kernel's last (initialization) task, it executes the <i>init</i> program.  This program reads a configuration file (<i>/etc/inittab</i>) which directs it to execute a startup script (found in <i>/etc/rc.d</i> on Red Hat distributions).  This in turn executes more scripts, eventually including the network script (<i>/etc/rc.d/init.d/network</i>).  (See Section <a href="#sec_i_examples">3.3</a> for examples of the script and file interactions.)

<p>
      </p><h3><a name="tth_sEc3.2.1">
3.2.1</a>&nbsp;&nbsp;The Network Initialization Script</h3>
The network initialization script sets environment variables to identify
 the host computer and establish whether or not the computer will use a 
network.  Depending on the values given, the network script turns on (or
 off) IP forwarding and IP fragmentation.  It also establishes the 
default router for all network traffic and the device to use to send 
such traffic.  Finally, it brings up any network devices using the <i>ifconfig</i> and <i>route</i>
 programs.  (In a dynamic environment, it would query the DHCP server 
for its network information instead of reading its own files.)

<p>
The script(s) involved in establishing networking can be very 
straightforward; it is entirely possible to have one big script that 
simply executes a series of commands that will set up a single machine 
properly.  However, most Linux distributions come with a large number of
 generic scripts that work for a wide variety of machine setups.  This 
leaves a lot of indirection and conditional execution in the scripts, 
but actually makes setting up any one machine much easier.  For example,
 on Red Hat distributions, the <i>/etc/rc.d/init.d/network</i> script runs several other scripts and sets up variables like <tt>interfaces_boot</tt> to keep track of which <i>/etc/sysconfig/network-scripts/ifup</i>
 scripts to run.  Tracing the process manually is very complicated, but 
simple modifications of only two configuration files (putting the proper
 names and IP addresses in the <i>/etc/sysconfig/network</i> and <i>/etc/sysconfig/network-scripts/ifcfg-eth0</i> files) sets up the entire system properly (and a GUI makes the process even simpler).

</p><p>
When the network script finishes, the FIB contains the specified routes 
to given hosts or networks and the routing cache and neighbor tables are
 empty.  When traffic begins to flow, the kernel will update the 
neighbor table and routing cache as part of the normal network 
operations.  (Network traffic may begin during initialization if a host 
is dynamically configured or consults a network clock, for example.)

</p><p>
      </p><h3><a name="tth_sEc3.2.2">
3.2.2</a>&nbsp;&nbsp;<i>ifconfig</i></h3>
The <i>ifconfig</i> program configures interface devices for use.  (This
 program, while very widely used, is not part of the kernel.)  It 
provides each device with its (IP) address, netmask, and broadcast 
address.  The device in turn will run its own initialization functions 
(to set any static variables) and register its interrupts and service 
routines with the kernel.  The <i>ifconfig</i> commands in the network script look like this:

<blockquote>
<tt>ifconfig ${DEVICE} ${IPADDR} netmask ${NMASK} broadcast ${BCAST}</tt>
</blockquote>
(where the variables are either written directly in the script or are defined in other scripts).

<p>
The <i>ifconfig</i> program can also provide information about currently
 configured network devices (calling with no arguments displays all the 
active interfaces; calling with the <tt>-a</tt> option displays all interfaces, active or not):

</p><blockquote>
<tt>ifconfig</tt>
</blockquote>
This provides all the information available about each working 
interface; addresses, status, packet statistics, and operating system 
specifics.  Usually there will be at least two interfaces - a network 
card and the loopback device.  The information for each interface looks 
like this (this is the <tt>viper</tt> interface):

<blockquote>
<pre>eth0  Link encap:Ethernet  HWaddr 00:C1:4E:7D:9E:25
      inet addr:172.16.1.1  Bcast:172.16.1.255  Mask:255.255.255.0
      UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
      RX packets:389016 errors:16534 dropped:0 overruns:0 frame:24522
      TX packets:400845 errors:0 dropped:0 overruns:0 carrier:0
      collisions:0 txqueuelen:100
      Interrupt:11 Base address:0xcc00
</pre></blockquote>
A superuser can use <i>ifconfig</i> to change interface settings from the command line; here is the syntax:

<blockquote>
<tt>ifconfig</tt> <i>interface [aftype] options <font face="symbol">|</font> address ...</i>
</blockquote>
... and some of the more useful calls:

<blockquote>
<tt>ifconfig eth0 down</tt> - shut down <tt>eth0</tt><br>
<tt>ifconfig eth1 up</tt> - activate <tt>eth1</tt><br>
<tt>ifconfig eth0 arp</tt> - enable ARP on <tt>eth0</tt><br>
<tt>ifconfig eth0 -arp</tt> - disable ARP on <tt>eth0</tt><br>
<tt>ifconfig eth0 netmask 255.255.255.0</tt> - set the <tt>eth0</tt> netmask<br>
<tt>ifconfig lo mtu 2000</tt> - set the loopback maximum transfer unit<br>
<tt>ifconfig eth1 172.16.0.7</tt> - set the <tt>eth1</tt> IP address
</blockquote>
Note that modifying an interface configuration can indirectly change the
 routing tables.   For example, changing the netmask may make some 
routes moot (including the default or even the route to the host itself)
 and the kernel will delete them.

<p>
      </p><h3><a name="tth_sEc3.2.3">
3.2.3</a>&nbsp;&nbsp;<i>route</i></h3>
The <i>route</i> program simply adds predefined routes for interface 
devices to the Forwarding Information Base (FIB).  This is not part of 
the kernel, either; it is a user program whose command in the script 
looks like this:

<blockquote>
<tt>route add -net ${NETWORK} netmask ${NMASK} dev ${DEVICE}</tt> -or-<br>
<tt>route add -host ${IPADDR} ${DEVICE}</tt><br>
</blockquote>
(where the variables are again spelled out or defined in other scripts).

<p>
The <i>route</i> program can also delete routes (if run with the <tt>del</tt> option) or provide information about the routes that are currently defined (if run with no options):

</p><blockquote>
<tt>route</tt>
</blockquote>
This displays the Kernel IP routing table (the FIB, not the routing cache).  For example (the <tt>stealth</tt> computer):

<blockquote>
<pre>Kernel IP routing table
Destination   Gateway        Genmask         Flags Metric Ref Use Iface
172.16.1.4    *              255.255.255.255 UH    0      0     0 eth0
172.16.1.0    *              255.255.255.0   U     0      0     0 eth0
127.0.0.0     *              255.0.0.0       U     0      0     0 lo
default       viper.u.edu    0.0.0.0         UG    0      0     0 eth0
</pre></blockquote>
A superuser can use <i>route</i> to add and delete IP routes from the command line; here is the basic syntax:

<blockquote>
<tt>route add</tt> <i>[-net<font face="symbol">|</font>-host] target [option arg]</i><br>
<tt>route del</tt> <i>[-net<font face="symbol">|</font>-host] target [option arg]</i>
</blockquote>
... and some useful examples:

<blockquote>
<tt>route add -host 127.16.1.0 eth1</tt> - adds a route to a host<br>
<tt>route add -net 172.16.1.0 netmask 255.255.255.0 eth0</tt> - adds a network<br>
<tt>route add default gw jeep</tt> - sets the default route through <tt>jeep</tt><br>
   (Note that a route to <tt>jeep</tt> must already be set up)<br>
<tt>route del -host 172.16.1.16</tt> - deletes entry for host <tt>172.16.1.16</tt>
</blockquote>

<p>
      </p><h3><a name="tth_sEc3.2.4">
3.2.4</a>&nbsp;&nbsp;Dynamic Routing Programs</h3>
If the computer is a router, the network script will run a routing program like <i>routed</i> or <i>gated</i>.
  Since most computers are always on the same hard-wired network with 
the same set of addresses and limited routing options, most computers do
 not run one of these programs.  (If an Ethernet cable is cut, traffic 
simply will not flow; there is no need to try to reroute or adjust 
routing tables.)  See Chapter&nbsp;<a href="#dyn_route">9</a> for more information about <i>routed</i>.

<p>
        </p><h2><a name="tth_sEc3.3">
3.3</a>&nbsp;&nbsp;Examples</h2><a name="sec_i_examples">
</a>
The following are examples of files for systems set up in three 
different ways and explanations of how they work.  Typically every 
computer will execute a network script that reads configuration files, 
even if the files tell the computer not to implement any networking.

<p>
      </p><h3><a name="tth_sEc3.3.1">
3.3.1</a>&nbsp;&nbsp;Home Computer</h3>
These files would be on a computer that is not permanently connected to a network, but has a modem for <tt>ppp</tt> access.  (This section does not reference a computer from the general example.)

<p>
This is the first file the network script will read; it sets several 
environment variables.  The first two variables set the computer to run 
networking programs (even though it is not on a network) but not to 
forward packets (since it has nowhere to send them).  The last two 
variables are generic entries.

</p><p>
<i>/etc/sysconfig/network</i>

</p><blockquote><tt>
NETWORKING=yes<br>
FORWARD_IPV4=false<br>
HOSTNAME=localhost.localdomain<br>
GATEWAY=</tt>
</blockquote>
After setting these variables, the network script will decide that it 
needs to configure at least one network device in order to be part of a 
network.  The next file (which is almost exactly the same on all Linux 
computers) sets up environment variables for the loopback device.  It 
names it and gives it its (standard) IP address, network mask, and 
broadcast address as well as any other device specific variables.  (The 
ONBOOT variable is a flag for the script program that tells it to 
configure this device when it boots.)  Most computers, even those that 
will never connect to the Internet, install the loopback device for 
inter-process communication.

<p>
<i>/etc/sysconfig/network-scripts/ifcfg-lo</i>

</p><blockquote><tt>
DEVICE=lo<br>
IPADDR=127.0.0.1<br>
NMASK=255.0.0.0<br>
NETWORK=127.0.0.0<br>
BCAST=127.255.255.255<br>
ONBOOT=yes<br>
NAME=loopback<br>
BOOTPROTO=none</tt>
</blockquote>
After setting these variables, the script will run the <i>ifconfig</i> program and stop, since there is nothing else to do at the moment.  However, when the <tt>ppp</tt> program connects to an Internet Service Provider, it will establish a <tt>ppp</tt>
 device and addressing and routes based on the dynamic values assigned 
by the ISP.  The DNS server and other connection information should be 
in an <i>ifcfg-ppp</i> file.

<p>
      </p><h3><a name="tth_sEc3.3.2">
3.3.2</a>&nbsp;&nbsp;Host Computer on a LAN</h3>
These files would be on a computer that is connected to a LAN; it has 
one Ethernet card that should come up whenever the computer boots.  
These files reflect entries on the <tt>stealth</tt> computer from the general example.

<p>
This is the first file the network script will read; again the first 
variables simply determine that the computer will do networking but that
 it will not forward packets.  The last four variables identify the 
computer and its link to the rest of the Internet (everything that is 
not on the LAN).

</p><p>
<i>/etc/sysconfig/network</i>

</p><blockquote><tt>
NETWORKING=yes<br>
FORWARD_IPV4=false<br>
HOSTNAME=stealth.cs.u.edu<br>
DOMAINNAME=cs.u.edu<br>
GATEWAY=172.16.1.1<br>
GATEWAYDEV=eth0<br></tt>
</blockquote>
After setting these variables, the network script will configure the 
network devices.  This file sets up environment variables for the 
Ethernet card.  It names the device and gives it its IP address, network
 mask, and broadcast address as well as any other device specific 
variables.  This kind of computer would also have a loopback 
configuration file exactly like the one for a non-networked computer.

<p>
<i>/etc/sysconfig/network-scripts/ifcfg-eth0</i>

</p><blockquote><tt>
DEVICE=eth0<br>
IPADDR=172.16.1.4<br>
NMASK=255.255.255.0<br>
NETWORK=172.16.1.0<br>
BCAST=172.16.1.255<br>
ONBOOT=yes<br>
BOOTPROTO=none<br></tt>
</blockquote>

<p>
After setting these variables, the network script will run the <i>ifconfig program</i> to start the device.  Finally, the script will run the <i>route</i> program to add the default route (<tt>GATEWAY</tt>) and any other specified routes (found in the <i>/etc/sysconfig/static-routes file</i>,
 if any).  In this case only the default route is specified, since all 
traffic either stays on the LAN (where the computer will use ARP to find
 other hosts) or goes through the router to get to the outside world.

</p><p>
      </p><h3><a name="tth_sEc3.3.3">
3.3.3</a>&nbsp;&nbsp;Network Routing Computer</h3>
These files would be on a computer that serves as a router between two 
networks; it has two Ethernet cards, one for each network.  One card is 
on a large network (WAN) connected to the Internet (through yet another 
router) while the other is on a subnetwork (LAN).  Computers on the LAN 
that need to communicate with the rest of the Internet send traffic 
through this computer (and vice versa).  These files reflect entries on 
the <tt>dodge/viper</tt> computer from the general example.

<p>
This is the first file the network script will read; it sets several 
environment variables.  The first two simply determine that the computer
 will do networking (since it is on a network) and that this one will 
forward packets (from one network to the other).  IP Forwarding is built
 into most kernels, but it is not active unless there is a 1 ``written''
 to the <i>/proc/net/ipv4/ip_forward</i> file.  (One of the network scripts performs an <tt>echo 1 &gt; /proc/net/ipv4/ip_forward</tt> if <tt>FORWARD_IPV4</tt>
 is true.)  The last four variables identify the computer and its link 
to the rest of the Internet (everything that is not on one of its own 
networks).

</p><p>
<i>/etc/sysconfig/network</i>

</p><blockquote><tt>
NETWORKING=yes<br>
FORWARD_IPV4=true<br>
HOSTNAME=dodge.u.edu<br>
DOMAINNAME=u.edu<br>
GATEWAY=172.16.0.1<br>
GATEWAYDEV=eth1<br></tt>
</blockquote>
After setting these variables, the network script will configure the 
network devices.  These files set up environment variables for two 
Ethernet cards.  They name the devices and give them their IP addresses,
 network masks, and broadcast addresses.  (Note that the BOOTPROTO 
variable remains defined for the second card.)  Again, this computer 
would have the standard loopback configuration file.

<p>
<i>/etc/sysconfig/network-scripts/ifcfg-eth0</i>

</p><blockquote><tt>
DEVICE=eth0<br>
IPADDR=172.16.1.1<br>
NMASK=255.255.255.0<br>
NETWORK=172.16.1.0<br>
BCAST=172.16.1.255<br>
ONBOOT=yes<br>
BOOTPROTO=static</tt>
</blockquote>

<p>
<i>/etc/sysconfig/network-scripts/ifcfg-eth1</i>

</p><blockquote><tt>
DEVICE=eth1<br>
IPADDR=172.16.0.7<br>
NMASK=255.255.0.0<br>
NETWORK=172.16.0.0<br>
BCAST=172.16.255.255<br>
ONBOOT=yes</tt>
</blockquote>
After setting these variables, the network script will run the <i>ifconfig</i> program to start each device.  Finally, the script will run the <i>route</i> program to add the default route (<tt>GATEWAY</tt>) and any other specified routes (found in the <i>/etc/sysconfig/static-routes file</i>,
 if any).  In this case again, the default route is the only specified 
route, since all traffic will go on the network indicated by the network
 masks or through the default router to reach the rest of the Internet.

<p>
        </p><h2><a name="tth_sEc3.4">
3.4</a>&nbsp;&nbsp;Linux and Network Program Functions</h2>
The following are alphabetic lists of the Linux kernel and network 
program functions that are most important to initialization, where they 
are in the source code, and what they do.  The <i>SOURCES</i> directory 
shown represents the directory that contains the source code for the 
given network file.  The executable files should come with any Linux 
distrbution, but the source code probably does not.

<p>
These sources are available as a package separate from the kernel source (Red Hat Linux uses the <i>rpm</i> package manager).  The code below is from the <i>net-tools-1.53-1</i> source code package, 29 August 1999.  The packages are available from the <i>www.redhat.com/apps/download</i> web page.  Once downloaded, <i>root</i> can install the package with the following commands (starting from the directory with the package):

</p><blockquote><tt>
rpm -i net-tools-1.53-1.src.rpm<br>
cd /usr/src/redhat/SOURCES<br>
tar xzf net-tools-1.53.tar.gz</tt>
</blockquote>
This creates a <i>/usr/src/redhat/SOURCES/net-tools-1.53</i> directory and fills it with the source code for the <i>ifconfig</i> and <i>route</i>
 programs (among others).  This process should be similar (but is 
undoubtably not exactly the same) for other Linux distributions.

<p>
      </p><h3><a name="tth_sEc3.4.1">
3.4.1</a>&nbsp;&nbsp;<i>ifconfig</i></h3>

<pre>devinet_ioctl() - net/ipv4/devinet.c (398)
  creates an info request (ifreq) structure and copies data from
      user to kernel space
  if it is an INET level request or action, executes it
  if it is a device request or action, calls a device function
  copies ifreq back into user memory
  returns 0 for success

&gt;&gt;&gt; ifconfig main() - SOURCES/ifconfig.c (478)
  opens a socket (only for use with ioctl function)
  searches command line arguments for options
  calls if_print() if there were no arguments or the only argument
      is an interface name
  loops through remaining arguments, setting or clearing flags or
      calling ioctl() to set variables for the interface

if_fetch() - SOURCES/lib/interface.c (338)
  fills in an interface structure with multiple calls to ioctl() for
      flags, hardware address, metric, MTU, map, and address information

if_print() - SOURCES/ifconfig.c (121)
  calls ife_print() for given (or all) interface(s)
      (calls if_readlist() to fill structure list if necessary and
      then displays information about each interface)

if_readlist() - SOURCES/lib/interface.c (261)
  opens /proc/net/dev and parses data into interface structures
  calls add_interface() for each device to put structures into a list

inet_ioctl() - net/ipv4/af_inet.c (855)
  executes a switch based on the command passed
      [for ifconfig, calls devinet_ioctl()]

ioctl() -
  jumps to appropriate handler routine [= inet_ioctl()]
</pre>

<p>
      </p><h3><a name="tth_sEc3.4.2">
3.4.2</a>&nbsp;&nbsp;<i>route</i></h3>

<pre>INET_rinput() - SOURCES/lib/inet_sr.c (305)
  checks for errors (cannot flush table or modify routing cache)
  calls INET_setroute()

INET_rprint() - SOURCES/lib/inet_gr.c (442)
  if the FIB flag is set, calls rprint_fib()
      (reads, parses, and displays contents of /proc/net/route)
  if the CACHE flag is set, calls rprint_cache()
      (reads, parses, and displays contents of /proc/net/rt_cache)

INET_setroute() - SOURCE/lib/inet_sr.c (57)
  establishes whether route is to a network or a host
  checks to see if address is legal
  loops through arguments, filling in rtentry structure
  checks for netmask conflicts
  creates a temporary socket
  calls ioctl() with rtentry to add or delete route
  closes socket and returns 0

ioctl() - 
  jumps to appropriate handler routine [= ip_rt_ioctl()]

ip_rt_ioctl() - net/ipv4/fib_frontend.c (246)
  converts passed parameters to routing table entry (struct rtentry)
  if deleting a route:
    calls fib_get_table() to find the appropriate table
    calls the table-&gt;tb_delete() function to remove it
  if adding a route
    calls fib_net_table() to find an entry point
    calls the table-&gt;tb_insert() function to add the entry
  returns 0 for success

&gt;&gt;&gt; route main() - SOURCES/route.c (106)
  calls initialization routines that set print and edit functions
  gets and parses the command line options (acts on some options
      directly by setting flags or displaying information)
  checks the options (prints a usage message if there is an error)
  if there are no options, calls route_info()
  if the option is to add, delete, or flush routes,
      calls route_edit() with the passed parameters
  if the option is invalid, prints a usage message
  returns result of

route_edit() - SOURCES/lib/setroute.c (69)
  calls get_aftype() to translate address family from text to a pointer
  checks for errors (unsupported or nonexistent family)
  calls the address family rinput() function [= INET_rinput()]

route_info() - SOURCES/lib/getroute.c (72)
  calls get_aftype() to translate address family from text to a pointer
  checks for errors (unsupported or nonexistent family)
  calls the address family rprint() function [= INET_rprint()]
</pre>

<p>
      </p><h1><a name="tth_chAp4">
Chapter 4     </a><br>Connections</h1>
<a name="connect">
</a>

<p>
This chapter presents the connection process.  It provides an overview 
of the connection process, a description of the socket data structures, 
an introduction to the routing system, and summarizes the implementation
 code within the kernel.

</p><p>
        </p><h2><a name="tth_sEc4.1">
4.1</a>&nbsp;&nbsp;Overview</h2>
The simplest form of networking is a connection between two hosts.  On 
each end, an application gets a socket, makes the transport layer 
connection, and then sends or receives packets.  In Linux, a socket is 
actually composed of two socket structures (one that contains the 
other).  When an application creates a socket, it is initialized but 
empty.  When the socket makes a connection (whether or not this involves
 traffic with the other end) the IP layer determines the route to the 
distant host and stores that information in the socket.  From that point
 on, all traffic using that connection uses that route - sent packets 
will travel through the correct device and the proper routers to the 
distant host, and received packets will appear in the socket's queue.

<p>
        </p><h2><a name="tth_sEc4.2">
4.2</a>&nbsp;&nbsp;Socket Structures</h2>
There are two main socket structures in Linux: general BSD sockets and 
IP specific INET sockets.  They are strongly interrelated; a BSD socket 
has an INET socket as a data member and an INET socket has a BSD socket 
as its owner.

<p>
BSD sockets are of type <tt>struct socket</tt> as defined in <i>include/linux/socket.h</i>.  BSD socket variables are usually named <tt>sock</tt> or some variation thereof.  This structure has only a few entries, the most important of which are described below.

</p><ul>

<li> <tt>struct proto_ops *ops</tt> - this structure contains pointers to protocol specific functions for implementing general socket behavior.  For example, <tt>ops- &gt; sendmsg</tt> points to the <tt>inet_sendmsg()</tt> function.

</li><li> <em>struct inode *inode</em> - this structure points to the file inode that is associated with this socket.

</li><li> <tt>struct sock *sk</tt> - this is the INET socket that is associated with this socket.
</li></ul>
<p>
INET sockets are of type <tt>struct sock</tt> as defined in <i>include/net/sock.h</i>.  INET socket variables are usually named <tt>sk</tt>
 or some variation thereof.  This structure has many entries related to a
 wide variety of uses; there are many hacks and configuration dependent 
fields.  The most important data members are described below:

</p><ul>

<li> <tt>struct sock *next, *pprev</tt> - all sockets are linked by various protocols, so these pointers allow the protocols to traverse them.

</li><li> <tt>struct dst_entry *dst_cache</tt> - this is a pointer to the route to the socket's other side (the destination for sent packets).

</li><li> <tt>struct sk_buff_head receive_queue</tt> - this is the head of the receive queue.

</li><li> <tt>struct sk_buff_head write_queue</tt> - this is the head of the send queue.

</li><li> <tt>__u32 saddr</tt> - the (Internet) source address for this socket.

</li><li> <tt>struct sk_buff_head back_log,error_queue</tt> - extra queues for a backlog of packets (not to be confused with the main backlog queue) and erroneous packets for this socket.

</li><li> <tt>struct proto *prot</tt> - this structure contains pointers to transport layer protocol specific functions.  For example, <tt>prot- &gt; recvmsg</tt> may point to the <tt>tcp_v4_recvmsg()</tt> function.

</li><li> <tt>union struct tcp_op af_tcp; tp_pinfo</tt> - TCP options for this socket.

</li><li> <tt>struct socket *sock</tt> - the parent BSD socket.

</li><li> Note that there are many more fields within this structure; 
these are only the most critical and non-obvious.  The rest are either 
not very important or have self-explanatory names (e.g., <tt>ip_ttl</tt> is the IP Time-To-Live counter).
</li></ul>
<p>
        </p><h2><a name="tth_sEc4.3">
4.3</a>&nbsp;&nbsp;Sockets and Routing</h2>
Sockets only go through the routing lookup process once for each 
destination (at connection time).  Because Linux sockets are so closely 
related to IP, they contain routes to the other end of a connection (in 
the <tt>sock- &gt; sk- &gt; dst_cache</tt> variable).  The transport protocols call the <tt>ip_route_connect()</tt>
 function to determine the route from host to host during the connection
 process; after that, the route is presumed not to change (though the 
path pointed to by the <tt>dst_cache</tt> may indeed change).  The 
socket does not need to do continuous routing table look-ups for each 
packet it sends or receives; it only tries again if something unexpected
 happens (such as a neighboring computer going down).  This is the 
benefit of using connections.

<p>
        </p><h2><a name="tth_sEc4.4">
4.4</a>&nbsp;&nbsp;Connection Processes</h2>

<p>
      </p><h3><a name="tth_sEc4.4.1">
4.4.1</a>&nbsp;&nbsp;Establishing Connections</h3>
Application programs establish sockets with a series of system calls 
that look up the distant address, establish a socket, and then connect 
to the machine on the other end.

<pre>    /* look up host */
    server = gethostbyname(SERVER_NAME);
    /* get socket */
    sockfd = socket(AF_INET, SOCK_STREAM, 0);
    /* set up address */
    address.sin_family = AF_INET;
    address.sin_port = htons(PORT_NUM);
    memcpy(&amp;address.sin_addr,server-&gt;h_addr,server-&gt;h_length);
    /* connect to server */
    connect(sockfd, &amp;address, sizeof(address));
</pre>
The <tt>gethostbyname()</tt> function simply looks up a host (such as 
``viper.cs.u.edu'') and returns a structure that contains an Internet 
(IP) address.  This has very little to do with routing (only inasmuch as
 the host may have to query the network to look up an address) and is 
simply a translation from a human readable form (text) to a computer 
compatible one (an unsigned 4 byte integer).

<p>
The <tt>socket()</tt> call is more interesting.  It creates a socket object, with the appropriate data type (a <tt>sock</tt>
 for INET sockets) and initializes it.  The socket contains inode 
information and protocol specific pointers for various network 
functions.  It also establishes defaults for queues (incoming, outgoing,
 error, and backlog), a dummy header info for TCP sockets, and various 
state information.

</p><p>
Finally, the <tt>connect()</tt> call goes to the protocol dependent connection routine (e.g., <tt>tcp_v4_connect()</tt> or <tt>udp_connect()</tt>).
  UDP simply establishes a route to the destination (since there is no 
virtual connection).  TCP establishes the route and then begins the TCP 
connection process, sending a packet with appropriate connection and 
window flags set.

</p><p>
      </p><h3><a name="tth_sEc4.4.2">
4.4.2</a>&nbsp;&nbsp;Socket Call Walk-Through</h3>

<ul>

<li> Check for errors in call

</li><li> Create (allocate memory for) socket object

</li><li> Put socket into INODE list

</li><li> Establish pointers to protocol functions (INET)

</li><li> Store values for socket type and protocol family

</li><li> Set socket state to closed

</li><li> Initialize packet queues
</li></ul>
<p>
      </p><h3><a name="tth_sEc4.4.3">
4.4.3</a>&nbsp;&nbsp;Connect Call Walk-Through</h3>

<ul>

<li> Check for errors

</li><li> Determine route to destination:
	
<ul>
	
<li> Check routing table for existing entry (return that if one exists)
	
</li><li> Look up destination in FIB
	
</li><li> Build new routing table entry
	
</li><li> Put entry in routing table and return it
	</li></ul>
<p>

</p></li><li> Store pointer to routing entry in socket

</li><li> Call protocol specific connection function (e.g., send a TCP connection packet)

</li><li> Set socket state to established
</li></ul>
<p>
      </p><h3><a name="tth_sEc4.4.4">
4.4.4</a>&nbsp;&nbsp;Closing Connections</h3>
Closing a socket is fairly straightforward.  An application calls <tt>close()</tt> on a socket, which becomes a <tt>sock_close()</tt>
 function call.  This changes the socket state to disconnecting and 
calls the data member's (INET socket's) release function.  The INET 
socket in turn cleans up its queues and calls the transport protocol's 
close function, <tt>tcp_v4_close()</tt> or <tt>udp_close()</tt>.  These 
perform any necessary actions (the TCP functions may send out packets to
 end the TCP connection) and then clean up any data structures they have
 remaining.  Note that no changes are made for routing; the (now-empty) 
socket no longer has a reference to the destination and the entry in the
 routing cache will remain until it is freed for lack of use.

<p>
      </p><h3><a name="tth_sEc4.4.5">
4.4.5</a>&nbsp;&nbsp;Close Walk-Through</h3>

<ul>

<li> Check for errors (does the socket exist?)

</li><li> Change the socket state to disconnecting to prevent further use

</li><li> Do any protocol closing actions (e.g., send a TCP packet with the FIN bit set)

</li><li> Free memory for socket data structures (TCP/UDP and INET)

</li><li> Remove socket from INODE list
</li></ul>
<p>
        </p><h2><a name="tth_sEc4.5">
4.5</a>&nbsp;&nbsp;Linux Functions</h2>
The following is an alphabetic list of the Linux kernel functions that 
are most important to connections, where they are in the source code, 
and what they do.  To follow function calls for creating a socket, begin
 with <tt>sock_create()</tt>.  To follow function calls for closing a socket, begin with <tt>sock_close()</tt>.

<pre>destroy_sock - net/ipv4/af_inet.c (195)
  deletes any timers
  calls any protocols specific destroy functions
  frees the socket's queues
  frees the socket structure itself

fib_lookup() - include/net/ip_fib.h (153)
  calls tb_lookup() [= fn_hash_lookup()] on local and main tables
  returns route or unreachable error

fn_hash_lookup() - net/ipv4/fib_hash.c (261)
  looks up and returns route to an address

inet_create() - net/ipv4/af_inet.c (326)
  calls sk_alloc() to get memory for sock
  initializes sock structure:
    sets proto structure to appropriate values for TCP or UDP
    calls sock_init_data()
    sets family,protocol,etc. variables
  calls the protocol init function (if any)

inet_release() - net/ipv4/af_inet.c (463)
  changes socket state to disconnecting
  calls ip_mc_drop_socket to leave multicast group (if necessary)
  sets owning socket's data member to NULL
  calls sk-&gt;prot-&gt;close() [=TCP/UDP_close()]

ip_route_connect() - include/net/route.h (140)
  calls ip_route_output() to get a destination address
  returns if the call works or generates an error
  otherwise clears the route pointer and try again

ip_route_output() - net/ipv4/route.c (1664)
  calculates hash value for address
  runs through table (starting at hash) to match addresses and TOS
  if there is a match, updates stats and return route entry
  else calls ip_route_output_slow()

ip_route_output_slow() - net/ipv4/route.c (1421)
  if source address is known, looks up output device
  if destination address is unknown, sets up loopback
  calls fib_lookup() to find route in FIB
  allocates memory new routing table entry
  initializes table entry with source, destination, TOS, output device,
      flags
  calls rt_set_nexthop() to find next destination
  returns rt_intern_hash(), which installs route in routing table

rt_intern_hash() - net/ipv4/route.c (526)
  loops through rt_hash_table (starting at hash value)
  if keys match, put rtable entry in front bucket
  else put rtable entry into hash table at hash

&gt;&gt;&gt; sock_close() - net/socket.c (476)
  checks if socket exists (could be null)
  calls sock_fasync() to remove socket from async list
  calls sock_release()

&gt;&gt;&gt; sock_create() - net/socket.c (571)
  checks parameters
  calls sock_alloc() to get an available inode for the socket and
      initialize it
  sets socket-&gt;type (to SOCK_STREAM, SOCK_DGRAM...)
  calls net_family-&gt;create() [= inet_create()] to build sock structure
  returns established socket

sock_init_data() - net/core/sock.c (1018)
  initializes all generic sock values

sock_release() - net/socket.c (309)
  changes state to disconnecting
  calls sock-&gt;ops-&gt;release() [= inet_release()]
  calls iput() to remove socket from inode list

sys_socket() - net/socket.c (639)
  calls sock_create() to get and initialize socket
  calls get_fd() to assign an fd to the socket
  sets socket-&gt;file to fcheck() (pointer to file)
  calls sock_release() if anything fails

tcp_close() - net/ipv4/tcp.c (1502)
  check for errors
  pops and discards all packets off incoming queue
  sends messages to destination to close connection (if required)

tcp_connect() - net/ipv4/tcp_output.c (910)
  completes connection packet with appropriate bits and window sizes set
  puts packet on socket output queue
  calls tcp_transmit_skb() to send packet, initiating TCP connection

tcp_v4_connect() - net/ipv4/tcp_ipv4.c (571)
  checks for errors
  calls ip_route_connect() to find route to destination
  creates connection packet  
  calls tcp_connect() to send packet

udp_close() - net/ipv4/udp.c (954)
  calls udp_v4_unhash() to remove socket from socket list
  calls destroy_sock()

udp_connect() - net/ipv4/udp.c (900)
  calls ip_route_connect() to find route to destination
  updates socket with source and destination addresses and ports
  changes socket state to established
  saves the destination route in sock-&gt;dst_cache
</pre>

<p>
      </p><h1><a name="tth_chAp5">
Chapter 5     </a><br>Sending Messages</h1>
<a name="sending">
</a>

<p>
This chapter presents the sending side of message trafficking.  It 
provides an overview of the process, examines the layers packets travel 
through, details the actions of each layer, and summarizes the 
implementation code within the kernel.

</p><p>
        </p><h2><a name="tth_sEc5.1">
5.1</a>&nbsp;&nbsp;Overview</h2>

<p><a name="tth_fIg5.1">
</a> 
<img src="linux-net_files/s_tx.gif" alt="s_tx.gif"><br>

 </p><center>Figure 5.1: Message transmission.</center>
<a name="s_tx">
</a>
<p>
</p><p>
An outgoing message begins with an application system call to write data
 to a socket.  The socket examines its own connection type and calls the
 appropriate send routine (typically INET).  The send function verifies 
the status of the socket, examines its protocol type, and sends the data
 on to the transport layer routine (such as TCP or UDP).  This protocol 
creates a new buffer for the outgoing packet (a socket buffer, or <tt>struct sk_buff skb</tt>),
 copies the data from the application buffer, and fills in its header 
information (such as port number, options, and checksum) before passing 
the new buffer to the network layer (usually IP).  The IP send functions
 fill in more of the buffer with its own protocol headers (such as the 
IP address, options, and checksum).  It may also fragment the packet if 
required.  Next the IP layer passes the packet to the link layer 
function, which moves the packet onto the sending device's <tt>xmit</tt>
 queue and makes sure the device knows that it has traffic to send.  
Finally, the device (such as a network card) tells the bus to send the 
packet.

</p><p>
        </p><h2><a name="tth_sEc5.2">
5.2</a>&nbsp;&nbsp;Sending Walk-Through</h2>

<p>
      </p><h3><a name="tth_sEc5.2.1">
5.2.1</a>&nbsp;&nbsp;Writing to a Socket</h3>

<ul>

<li> Write data to a socket (application)

</li><li> Fill in message header with location of data (socket)

</li><li> Check for basic errors - is socket bound to a port? can the socket send messages? is there something wrong with the socket?

</li><li> Pass the message header to appropriate transport protocol (INET socket)
</li></ul>
<p>
      </p><h3><a name="tth_sEc5.2.2">
5.2.2</a>&nbsp;&nbsp;Creating a Packet with UDP</h3>

<ul>

<li> Check for errors - is the data too big? is it a UDP connection?

</li><li> Make sure there is a route to the destination (call the IP 
routing routines if the route is not already established; fail if there 
is no route)

</li><li> Create a UDP header (for the packet)

</li><li> Call the IP build and transmit function
</li></ul>
<p>
      </p><h3><a name="tth_sEc5.2.3">
5.2.3</a>&nbsp;&nbsp;Creating a Packet with TCP</h3>

<ul>

<li> Check connection - is it established? is it open? is the socket working?

</li><li> Check for and combine data with partial packets if possible

</li><li> Create a packet buffer

</li><li> Copy the payload from user space

</li><li> Add the packet to the outbound queue

</li><li> Build current TCP header into packet (with ACKs, SYN, etc.)

</li><li> Call the IP transmit function
</li></ul>
<p>
      </p><h3><a name="tth_sEc5.2.4">
5.2.4</a>&nbsp;&nbsp;Wrapping a Packet in IP</h3>

<ul>

<li> Create a packet buffer (if necessary - UDP)

</li><li> Look up route to destination (if necessary - TCP)

</li><li> Fill in the packet IP header

</li><li> Copy the transport header and the payload from user space

</li><li> Send the packet to the destination route's device output funtion
</li></ul>
<p>
      </p><h3><a name="tth_sEc5.2.5">
5.2.5</a>&nbsp;&nbsp;Transmitting a Packet</h3>

<ul>

<li> Put the packet on the device output queue

</li><li> Wake up the device

</li><li> Wait for the scheduler to run the device driver

</li><li> Test the medium (device)

</li><li> Send the link header

</li><li> Tell the bus to transmit the packet over the medium
</li></ul>
<p>
        </p><h2><a name="tth_sEc5.3">
5.3</a>&nbsp;&nbsp;Linux Functions</h2>
The following is an alphabetic list of the Linux kernel functions that 
are most important to message traffic, where they are in the source 
code, and what they do.  To follow function calls, begin with <tt>sock_write()</tt>.

<pre>dev_queue_xmit() - net/core/dev.c (579)
  calls start_bh_atomic()
  if device has a queue
    calls enqueue() to add packet to queue
    calls qdisc_wakeup() [= qdisc_restart()] to wake device
  else calls hard_start_xmit()
  calls end_bh_atomic()

DEVICE-&gt;hard_start_xmit() - device dependent, drivers/net/DEVICE.c
  tests to see if medium is open
  sends header
  tells bus to send packet
  updates status

inet_sendmsg() - net/ipv4/af_inet.c (786)
  extracts pointer to socket sock
  checks socket to make sure it is working
  verifies protocol pointer
  returns sk-&gt;prot[tcp/udp]-&gt;sendmsg()

ip_build_xmit - net/ipv4/ip_output.c (604)
  calls sock_alloc_send_skb() to establish memory for skb
  sets up skb header
  calls getfrag() [= udp_getfrag()]  to copy buffer from user space
  returns rt-&gt;u.dst.output() [= dev_queue_xmit()]

ip_queue_xmit() - net/ipv4/ip_output.c (234)
  looks up route
  builds IP header
  fragments if required
  adds IP checksum
  calls skb-&gt;dst-&gt;output() [= dev_queue_xmit()]

qdisc_restart() - net/sched/sch_generic.c (50)
  pops packet off queue
  calls dev-&gt;hard_start_xmit()
  updates status
  if there was an error, requeues packet

sock_sendmsg() - net/socket.c (325)
  calls scm_sendmsg() [socket control message]
  calls sock-&gt;ops[inet]-&gt;sendmsg() and destroys scm

&gt;&gt;&gt; sock_write() - net/socket.c (399)
  calls socki_lookup() to associate socket with fd/file inode
  creates and fills in message header with data size/addresses
  returns sock_sendmsg()

tcp_do_sendmsg() - net/ipv4/tcp.c  (755)
  waits for connection, if necessary
  calls skb_tailroom() and adds data to waiting packet if possible
  checks window status
  calls sock_wmalloc() to get memory for skb
  calls csum_and_copy_from_user() to copy packet and do checksum
  calls tcp_send_skb()

tcp_send_skb() - net/ipv4/tcp_output.c (160)
  calls __skb_queue_tail() to add packet to queue
  calls tcp_transmit_skb() if possible

tcp_transmit_skb() - net/ipv4/tcp_output.c (77)
  builds TCP header and adds checksum
  calls tcp_build_and_update_options()
  checks ACKs,SYN
  calls tp-&gt;af_specific[ip]-&gt;queue_xmit()

tcp_v4_sendmsg() - net/ipv4/tcp_ipv4.c (668)
  checks for IP address type, opens connection, port addresses
  returns tcp_do_sendmsg()

udp_getfrag() - net/ipv4/udp.c (516)
  copies and checksums a buffer from user space

udp_sendmsg() - net/ipv4/udp.c (559)
  checks length, flags, protocol
  sets up UDP header and address info
  checks multicast
  fills in route
  fills in remainder of header
  calls ip_build_xmit()
  updates UDP status
  returns err
</pre>

<p>
      </p><h1><a name="tth_chAp6">
Chapter 6     </a><br>Receiving Messages</h1>
<a name="receiving">
</a>

<p>
This chapter presents the receiving side of message trafficking.  It 
provides an overview of the process, examines the layers packets travel 
through, details the actions of each layer, and summarizes the 
implementation code within the kernel.

</p><p>
        </p><h2><a name="tth_sEc6.1">
6.1</a>&nbsp;&nbsp;Overview</h2>

<p><a name="tth_fIg6.1">
</a> 
<img src="linux-net_files/r_rx.gif" alt="r_rx.gif"><br>

 </p><center>Figure 6.1: Receiving messages.</center>
<a name="r_rx">
</a>
<p>
</p><p>
An incoming message begins with an interrupt when the system notifies 
the device that a message is ready.  The device allocates storage space 
and tells the bus to put the message into that space.  It then passes 
the packet to the link layer, which puts it on the backlog queue, and 
marks the network flag for the next ``bottom-half'' run.

</p><p>
The bottom-half is a Linux system that minimizes the amount of work done
 during an interrupt.  Doing a lot of processing during an interrupt is 
not good precisely because it interrupts a running process; instead, 
interrupt handlers have a ``top-half'' and a ``bottom-half''.  When the 
interrupt arrives, the top-half runs and takes care of any critical 
operations, such as moving data from a device queue into kernel memory. 
 It then marks a flag that tells the kernel that there is more work to 
do - when the processor has time - and returns control to the current 
process.  The next time the process scheduler runs, it sees the flag, 
does the extra work, and only then schedules any normal processes.

</p><p>
When the process scheduler sees that there are networking tasks to do it
 runs the network bottom-half.  This function pops packets off of the 
backlog queue, matches them to a known protocol (typically IP), and 
passes them to that protocol's receive function.  The IP layer examines 
the packet for errors and routes it; the packet will go into an outgoing
 queue (if it is for another host) or up to the transport layer (such as
 TCP or UDP).  This layer again checks for errors, looks up the socket 
associated with the port specified in the packet, and puts the packet at
 the end of that socket's receive queue.

</p><p>
Once the packet is in the socket's queue, the socket will wake up the 
application process that owns it (if necessary).  That process may then 
make or return from a <tt>read</tt> system call that copies the data 
from the packet in the queue into its own buffer.  (The process may also
 do nothing for the time being if it was not waiting for the packet, and
 get the data off the queue when it needs it.)

</p><p>
        </p><h2><a name="tth_sEc6.2">
6.2</a>&nbsp;&nbsp;Receiving Walk-Through</h2>

<p>
      </p><h3><a name="tth_sEc6.2.1">
6.2.1</a>&nbsp;&nbsp;Reading from a Socket (Part I)</h3>

<ul>

<li> Try to read data from a socket (application)

</li><li> Fill in message header with location of buffer (socket)

</li><li> Check for basic errors - is the socket bound to a port? can 
the socket accept messages? is there something wrong with the socket?

</li><li> Pass the message header with to the appropriate transport protocol (INET socket)

</li><li> Sleep until there is enough data to read from the socket (TCP/UDP)
</li></ul>
<p>
      </p><h3><a name="tth_sEc6.2.2">
6.2.2</a>&nbsp;&nbsp;Receiving a Packet</h3>

<ul>

<li> Wake up the receiving device (interrupt)

</li><li> Test the medium (device)

</li><li> Receive the link header

</li><li> Allocate space for the packet

</li><li> Tell the bus to put the packet into the buffer

</li><li> Put the packet on the backlog queue

</li><li> Set the flag to run the network bottom half when possible

</li><li> Return control to the current process
</li></ul>
<p>
      </p><h3><a name="tth_sEc6.2.3">
6.2.3</a>&nbsp;&nbsp;Running the Network ``Bottom Half''</h3>

<ul>

<li> Run the network bottom half (scheduler)

</li><li> Send any packets that are waiting to prevent interrupts (bottom half)

</li><li> Loop through all packets in the backlog queue and pass the packet up to its Internet reception protocol - IP

</li><li> Flush the sending queue again

</li><li> Exit the bottom half
</li></ul>
<p>
      </p><h3><a name="tth_sEc6.2.4">
6.2.4</a>&nbsp;&nbsp;Unwrapping a Packet in IP</h3>

<ul>

<li> Check packet for errors - too short? too long? invalid version? checksum error?

</li><li> Defragment the packet if necessary

</li><li> Get the route for the packet (could be for this host or could need to be forwarded)

</li><li> Send the packet to its destination handling routine (TCP or UDP reception, or possibly retransmission to another host)
</li></ul>
<p>
      </p><h3><a name="tth_sEc6.2.5">
6.2.5</a>&nbsp;&nbsp;Accepting a Packet in UDP</h3>

<ul>

<li> Check UDP header for errors

</li><li> Match destination to socket

</li><li> Send an error message back if there is no such socket

</li><li> Put packet into appropriate socket receive queue

</li><li> Wake up any processes waiting for data from that socket
</li></ul>
<p>
      </p><h3><a name="tth_sEc6.2.6">
6.2.6</a>&nbsp;&nbsp;Accepting a Packet in TCP</h3>

<ul>

<li> Check sequence and flags; store packet in correct space if possible

</li><li> If already received, send immediate ACK and drop packet

</li><li> Determine which socket packet belongs to

</li><li> Put packet into appropriate socket receive queue

</li><li> Wake up and processes waiting for data from that socket
</li></ul>
<p>
      </p><h3><a name="tth_sEc6.2.7">
6.2.7</a>&nbsp;&nbsp;Reading from a Socket (Part II)</h3>

<ul>

<li> Wake up when data is ready (socket)

</li><li> Call transport layer receive function

</li><li> Move data from receive queue to user buffer (TCP/UDP)

</li><li> Return data and control to application (socket)
</li></ul>
<p>
        </p><h2><a name="tth_sEc6.3">
6.3</a>&nbsp;&nbsp;Linux Functions</h2>
The following is an alphabetic list of the Linux kernel functions that 
are most important to receiving traffic, where they are in the source 
code, and what they do.  To follow functions calls from the network up, 
start with <tt>DEVICE_rx()</tt>.  To follow functions calls from the application down, start with <tt>sock_read()</tt>.

<pre>&gt;&gt;&gt; DEVICE_rx() - device dependent, drivers/net/DEVICE.c
  (gets control from interrupt)
  performs status checks to make sure it should be receiving
  calls dev_alloc_skb() to reserve space for packet
  gets packet off of system bus
  calls eth_type_trans() to determine protocol type
  calls netif_rx()
  updates card status
  (returns from interrupt)

inet_recvmsg() - net/ipv4/af_inet.c (764)
  extracts pointer to socket sock
  checks socket to make sure it is accepting
  verifies protocol pointer
  returns sk-&gt;prot[tcp/udp]-&gt;recvmsg()

ip_rcv() - net/ipv4/ip_input.c (395)
  examines packet for errors:
    invalid length (too short or too long)
    incorrect version (not 4)
    invalid checksum
  calls __skb_trim() to remove padding
  defrags packet if necessary
  calls ip_route_input() to route packet
  examines and handle IP options
  returns skb-&gt;dst-&gt;input() [= tcp_rcv,udp_rcv()]

net_bh() - net/core/dev.c (835)
  (run by scheduler)
  if there are packets waiting to go out, calls qdisc_run_queues()
      (see sending section)
  while the backlog queue is not empty
    let other bottom halves run
    call skb_dequeue() to get next packet
    if the packet is for someone else (FASTROUTED) put onto send queue
    loop through protocol lists (taps and main) to match protocol type
    call pt_prev-&gt;func() [= ip_rcv()] to pass packet to appropriate
        protocol
  call qdisc_run_queues() to flush output (if necessary)

netif_rx() - net/core/dev.c (757)
  puts time in skb-&gt;stamp
  if backlog queue is too full, drops packet
  else
    calls skb_queue_tail() to put packet into backlog queue
    marks bottom half for later execution

sock_def_readable() - net/core/sock.c (989)
  calls wake_up_interruptible() to put waiting process on run queue
  calls sock_wake_async() to send SIGIO to socket process

sock_queue_rcv_skb() - include/net/sock.h (857)
  calls skb_queue_tail() to put packet in socket receive queue
  calls sk-&gt;data_ready() [= sock_def_readable()]

&gt;&gt;&gt; sock_read() - net/socket.c (366)
  sets up message headers
  returns sock_recvmsg() with result of read

sock_recvmsg() - net/socket.c (338)
  reads socket management packet (scm) or packet by
      calling sock-&gt;ops[inet]-&gt;recvmsg()

tcp_data() - net/ipv4/tcp_input.c (1507)
  shrinks receive queue if necessary
  calls tcp_data_queue() to queue packet
  calls sk-&gt;data_ready() to wake socket

tcp_data_queue() - net/ipv4/tcp_input.c (1394)
  if packet is out of sequence:
    if old, discards immediately
    else calculates appropriate storage location
  calls __skb_queue_tail() to put packet in socket receive queue
  updates connection state

tcp_rcv_established() - net/ipv4/tcp_input.c (1795)
  if fast path
    checks all flags and header info
    sends ACK
    calls _skb_queue_tail() to put packet in socket receive queue
  else (slow path)
    if out of sequence, sends ACK and drops packet
    check for FIN, SYN, RST, ACK
    calls tcp_data() to queue packet
    sends ACK

tcp_recvmsg() - net/ipv4/tcp.c (1149)
  checks for errors
  wait until there is at least one packet available
  cleans up socket if connection closed
  calls memcpy_toiovec() to copy payload from the socket buffer into
      the user space
  calls cleanup_rbuf() to release memory and send ACK if necessary
  calls remove_wait_queue() to wake process (if necessary)

udp_queue_rcv_skb() - net/ipv4/udp.c (963)
  calls sock_queue_rcv_skb()
  updates UDP status (frees skb if queue failed)

udp_rcv() - net/ipv4/udp.c (1062)
  gets UDP header, trims packet, verifies checksum (if required)
  checks multicast
  calls udp_v4_lookup() to match packet to socket
  if no socket found, send ICMP message back, free skb, and stop
  calls udp_deliver() [= udp_queue_rcv_skb()]

udp_recvmsg() - net/ipv4/udp.c (794)
  calls skb_recv_datagram() to get packet from queue
  calls skb_copy_datagram_iovec() to move the payload from the socket buffer
      into the user space
  updates the socket timestamp
  fills in the source information in the message header
  frees the packet memory
</pre>

<p>
      </p><h1><a name="tth_chAp7">
Chapter 7     </a><br>IP Forwarding</h1>
<a name="forward">
</a>

<p>
This chapter presents the pure routing side (by IP forwarding) of 
message traffic.  It provides an overview of the process, examines the 
layers packets travel through, details the actions of each layer, and 
summarizes the implementation code within the kernel.

</p><p>
        </p><h2><a name="tth_sEc7.1">
7.1</a>&nbsp;&nbsp;Overview</h2>

<p>
See Figure <a href="#f_fwd">7.1</a> for an abstract diagram of the the 
forwarding process.  (It is essentially a combination of the receiving 
and sending processes.)

</p><p><a name="tth_fIg7.1">
</a> 
<img src="linux-net_files/f_fwd.gif" alt="f_fwd.gif"><br>

 </p><center>Figure 7.1: IP forwarding.</center>
<a name="f_fwd">
</a>
<p>
</p><p>
A forwarded packet arrives with an interrupt when the system notifies 
the device that a message is ready.  The device allocates storage space 
and tells the bus to put the message into that space.  It then passes 
the packet to the link layer, which puts it on the backlog queue, marks 
the network flag for the next ``bottom-half'' run, and returns control 
to the current process.

</p><p>
When the process scheduler next runs, it sees that there are networking 
tasks to do and runs the network ``bottom-half''.  This function pops 
packets off of the backlog queue, matches them to IP, and passes them to
 the receive function.  The IP layer examines the packet for errors and 
routes it; the packet will go up to the transport layer (such as TCP or 
UDP if it is for this host) or sideways to the IP forwarding function.  
Within the forwarding function, IP checks the packet and sends an ICMP 
message back to the sender if anything is wrong.  It then copies the 
packet into a new buffer and fragments it if necessary.

</p><p>
Finally the IP layer passes the packet to the link layer function, which moves the packet onto the sending device's <tt>xmit</tt>
 queue and makes sure the device knows that it has traffic to send.  
Finally, the device (such as a network card) tells the bus to send the 
packet.

</p><p>
        </p><h2><a name="tth_sEc7.2">
7.2</a>&nbsp;&nbsp;IP Forward Walk-Through</h2>

<p>
      </p><h3><a name="tth_sEc7.2.1">
7.2.1</a>&nbsp;&nbsp;Receiving a Packet</h3>

<ul>

<li> Wake up the receiving device (interrupt)

</li><li> Test the medium (device)

</li><li> Receive the link header

</li><li> Allocate space for the packet

</li><li> Tell the bus to put the packet into the buffer

</li><li> Put the packet on the backlog queue

</li><li> Set the flag to run the network bottom half when possible

</li><li> Return control to the current process
</li></ul>
<p>
      </p><h3><a name="tth_sEc7.2.2">
7.2.2</a>&nbsp;&nbsp;Running the Network ``Bottom Half''</h3>

<ul>

<li> Run the network bottom half (scheduler)

</li><li> Send any packets that are waiting to prevent interrupts (net_bh)

</li><li> Loop through all packets in the backlog queue and pass the packet up to its Internet reception protocol - IP

</li><li> Flush the sending queue again

</li><li> Exit the bottom half
</li></ul>
<p>
      </p><h3><a name="tth_sEc7.2.3">
7.2.3</a>&nbsp;&nbsp;Examining a Packet in IP</h3>

<ul>

<li> Check packet for errors - too short? too long? invalid version? checksum error?

</li><li> Defragment the packet if necessary

</li><li> Get the route for the packet (could be for this host or could need to be forwarded)

</li><li> Send the packet to its destination handling routine (retransmission to another host in this case)
</li></ul>
<p>
      </p><h3><a name="tth_sEc7.2.4">
7.2.4</a>&nbsp;&nbsp;Forwarding a Packet in IP</h3>

<ul>

<li> Check TTL field (and decrement it)

</li><li> Check packet for improper (undesired) routing

</li><li> Send ICMP back to sender if there are any problems

</li><li> Copy packet into new buffer and free old one

</li><li> Set any IP options

</li><li> Fragment packet if it is too big for new destination

</li><li> Send the packet to the destination route's device output function
</li></ul>
<p>
      </p><h3><a name="tth_sEc7.2.5">
7.2.5</a>&nbsp;&nbsp;Transmitting a Packet</h3>

<ul>

<li> Put the packet on the device output queue

</li><li> Wake up the device

</li><li> Wait for the scheduler to run the device driver

</li><li> Test the medium (device)

</li><li> Send the link header

</li><li> Tell the bus to transmit the packet over the medium
</li></ul>
<p>
        </p><h2><a name="tth_sEc7.3">
7.3</a>&nbsp;&nbsp;Linux Functions</h2>
The following is an alphabetic list of the Linux kernel functions that 
are most important to IP forwarding, where they are in the source code, 
and what they do.  To follow the functions calls, start with 
DEVICE_rx().

<pre>dev_queue_xmit() - net/core/dev.c (579)
  calls start_bh_atomic()
  if device has a queue
    calls enqueue() to add packet to queue
    calls qdisc_wakeup() [= qdisc_restart()] to wake device
  else calls hard_start_xmit()
  calls end_bh_atomic()

DEVICE-&gt;hard_start_xmit() - device dependent, drivers/net/DEVICE.c
  tests to see if medium is open
  sends header
  tells bus to send packet
  updates status

&gt;&gt;&gt; DEVICE_rx() - device dependent, drivers/net/DEVICE.c
  (gets control from interrupt)
  performs status checks to make sure it should be receiving
  calls dev_alloc_skb() to reserve space for packet
  gets packet off of system bus
  calls eth_type_trans() to determine protocol type
  calls netif_rx()
  updates card status
  (returns from interrupt)

ip_finish_output() - include/net/ip.h (140)
  sets sending device to output device for given route
  calls output function for destination [= dev_queue_xmit()]

ip_forward() - net/ipv4/ip_forward.c (72)
  checks for router alert
  if packet is not meant for any host, drops it
  if TTL has expired, drops packet and sends ICMP message back
  if strict route cannot be followed, drops packet and sends ICMP
      message back to sender
  if necessary, sends ICMP message telling sender packet is redirected
  copies and releases old packet
  decrements TTL
  if there are options, calls ip_forward_options() to set them
  calls ip_send()

ip_rcv() - net/ipv4/ip_input.c (395)
  examines packet for errors:
    invalid length (too short or too long)
    incorrect version (not 4)
    invalid checksum
  calls __skb_trim() to remove padding
  defrags packet if necessary
  calls ip_route_input() to route packet
  examines and handle IP options
  returns skb-&gt;dst-&gt;input() [= ip_forward()]

ip_route_input() - net/ipv4/route.c (1366)
  calls rt_hash_code() to get index for routing table
  loops through routing table (starting at hash) to find match for packet
  if it finds match:
    updates stats for route (time and usage)
    sets packet destination to routing table entry
    returns success
  else 
    checks for multicasting addresses
    returns result of ip_route_input_slow() (attempted routing)

ip_route_output_slow() - net/ipv4/route.c (1421)
  if source address is known, looks up output device
  if destination address is unknown, set up loopback
  calls fib_lookup() to find route
  allocates memory new routing table entry
  initializes table entry with source, destination, TOS, output device,
      flags
  calls rt_set_nexthop() to find next destination
  returns rt_intern_hash(), which installs route in routing table

ip_send() - include/net/ip.h (162)
  calls ip_fragment() if packet is too big for device
  calls ip_finish_output()

net_bh() - net/core/dev.c (835)
  (run by scheduler)
  if there are packets waiting to go out, calls qdisc_run_queues()
      (see sending section)
  while the backlog queue is not empty
    let other bottom halves run
    call skb_dequeue() to get next packet
    if the packet is for someone else (FASTROUTED) put onto send queue
    loop through protocol lists (taps and main) to match protocol type
    call pt_prev-&gt;func() [= ip_rcv()] to pass packet to appropriate
        protocol
  call qdisc_run_queues() to flush output (if necessary)

netif_rx() - net/core/dev.c (757)
  puts time in skb-&gt;stamp
  if backlog queue is too full, drops packet
  else
    calls skb_queue_tail() to put packet into backlog queue
    marks bottom half for later execution

qdisc_restart() - net/sched/sch_generic.c (50)
  pops packet off queue
  calls dev-&gt;hard_start_xmit()
  updates status
  if there was an error, requeues packet

rt_intern_hash() - net/ipv4/route.c (526)
  puts new route in routing table
</pre>

<p>
      </p><h1><a name="tth_chAp8">
Chapter 8     </a><br>Basic Internet Protocol Routing</h1>
<a name="routing">
</a>

<p>
This chapter presents the basics of IP Routing.  It provides an overview
 of how routing works, examines how routing tables are established and 
updated, and summarizes the implementation code within the kernel.

</p><p>
        </p><h2><a name="tth_sEc8.1">
8.1</a>&nbsp;&nbsp;Overview</h2>
Linux maintains three sets of routing data - one for computers that are 
directly connected to the host (via a LAN, for example) and two for 
computers that are only indirectly connected (via IP networking).  
Examine Figure&nbsp;<a href="#r_overview">8.1</a> to see how entries for a computer in the general example might look.

<p><a name="tth_fIg8.1">
</a> 
<img src="linux-net_files/r_overview.gif" alt="r_overview.gif"><br>

 </p><center>Figure 8.1: General routing table example.</center>
<a name="r_overview">
</a>
<p>
</p><p>
The neighbor table contains address information for computers that are 
physically connected to the host (hence the name ``neighbor'').  It 
includes information on which device connects to which neighbor and what
 protocols to use in exchanging data.  Linux uses the Address Resolution
 Protocol (ARP) to maintain and update this table; it is dynamic in that
 entries are added when needed but eventually disappear if not used 
again within a certain time.  (However, administrators can set up 
entries to be permanent if doing so makes sense.)

</p><p>
Linux uses two complex sets of routing tables to maintain IP addresses: 
an all-purpose Forwarding Information Base (FIB) with directions to 
every possible address, and a smaller (and faster) routing cache with 
data on frequently used routes.  When an IP packet needs to go to a 
distant host, the IP layer first checks the routing cache for an entry 
with the appropriate source, destination, and type of service.  If there
 is such an entry, IP uses it.  If not, IP requests the routing 
information from the more complete (but slower) FIB, builds a new cache 
entry with that data, and then uses the new entry.  While the FIB 
entries are semi-permanent (they usually change only when routers come 
up or go down) the cache entries remain only until they become obsolete 
(they are unused for a ``long'' period).

</p><p>
        </p><h2><a name="tth_sEc8.2">
8.2</a>&nbsp;&nbsp;Routing Tables</h2>
Note: within these tables, there are references to variables of types such as <tt>u32</tt> (host byte order) and <tt>__u32</tt> (network byte order).  On the Intel architecture they are both equivalent to <tt>unsigned int</tt>s and in point of fact they are translated (using the <tt>ntohl</tt> function) anyway; the type merely gives an indication of the order in which the value it contains is stored.

<p>
      </p><h3><a name="tth_sEc8.2.1">
8.2.1</a>&nbsp;&nbsp;The Neighbor Table</h3>
The Neighbor Table (whose structure is shown in Figure&nbsp;<a href="#r_neigh_struct">8.2</a>)
 contains information about computers that are physically linked with 
the host computer. (Note that the source code uses the European 
spelling, ``neighbour''.)  Entries are not (usually) persistent; this 
table may contain no entries (if the computer has not passed any network
 traffic recently) or may contain as many entries as there are computers
 physically connected to its network (if it has communicated with all of
 them recently).  Entries in the table are actually other table 
structures which contain addressing, device, protocol, and statistical 
information.

<p><a name="tth_fIg8.2">
</a> 
<img src="linux-net_files/r_neigh_struct.gif" alt="r_neigh_struct.gif"><br>

 </p><center>Figure 8.2: Neighbor Table data structure relationships.</center>
<a name="r_neigh_struct">
</a>
<p>
</p><p>
<tt>struct neigh_table *neigh_tables</tt> - this global variable is a 
pointer to a list of neighbor tables; each table contains a set of 
general functions and data and a hash table of specific information 
about a set of neighbors.  This is a very detailed, low level table 
containing specific information such as the approximate transit time for
 messages, queue sizes, device pointers, and pointers to device 
functions.

</p><p>
Neighbor Table (<tt>struct neigh_table</tt>) Structure - this structure 
(a list element) contains common neighbor information and table of 
neighbor data and pneigh data.  All computers connected through a single
 type of connection (such as a single Ethernet card) will be in the same
 table.

</p><ul>

<li> <tt>struct neigh_table *next</tt> - pointer to the next table in the list.

</li><li> <tt>struct neigh_parms parms</tt> - structure containing message travel time, queue length, and statistical information; this is actually the head of a list.

</li><li> <tt>struct neigh_parms *parms_list</tt> - pointer to a list of information structures.

</li><li> <tt>struct neighbour *hash_buckets[]</tt> - hash table of neighbors associated with this table; there are <tt>NEIGH_HASHMASK+1</tt> (32) buckets.

</li><li> <tt>struct pneigh_entry *phash_buckets[]</tt> - hash table of structures containing device pointers and keys; there are <tt>PNEIGH_HASHMASK+1</tt> (16) buckets.

</li><li> Other fields include timer information, function pointers, locks, and statistics.
</li></ul>
<p>
Neighbor Data (<tt>struct neighbour</tt>) Structure - these structures contain the specific information about each neighbor.

</p><ul>

<li> <tt>struct device *dev</tt> - pointer to the device that is connected to this neighbor.

</li><li> <tt>__u8 nud_state</tt> - status flags; values can be incomplete, reachable, stale, etc.; also contains state information for permanence and ARP use.

</li><li> <tt>struct hh_cache *hh</tt> - pointer to cached hardware header for transmissions to this neighbor.

</li><li> <tt>struct sk_buff_head arp_queue</tt> - pointer to ARP packets for this neighbor.

</li><li> Other fields include list pointers, function (table) pointers, and statistical information.
</li></ul>
<p>
      </p><h3><a name="tth_sEc8.2.2">
8.2.2</a>&nbsp;&nbsp;The Forwarding Information Base</h3><a name="sec_the_FIB">
</a>

<p><a name="tth_fIg8.3">
</a> 
<img src="linux-net_files/r_fib_gen.gif" alt="r_fib_gen.gif"><br>

 </p><center>Figure 8.3: Forwarding Information Base (FIB) conceptual organization.</center>
<a name="r_fib_gen">
</a>
<p>
</p><p>
The Forwarding Information Base (FIB) is the most important routing 
structure in the kernel; it is a complex structure that contains the 
routing information needed to reach any valid IP address by its network 
mask.  Essentially it is a large table with general address information 
at the top and very specific information at the bottom.  The IP layer 
enters the table with the destination address of a packet and compares 
it to the most specific netmask to see if they match.  If they do not, 
IP goes on to the next most general netmask and again compares the two. 
 When it finally finds a match, IP copies the ``directions'' to the 
distant host into the routing cache and sends the packet on its way.  
See Figures&nbsp;<a href="#r_fib_gen">8.3</a>&nbsp;and&nbsp;<a href="#r_fib_struct">8.4</a> for the organization and data structures used in the FIB - note that Figure&nbsp;<a href="#r_fib_gen">8.3</a>
 shows some different FIB capabilities, like two sets of network 
information for a single zone, and so does not follow the general 
example.)

</p><p>
<tt>struct fib_table *local_table, *main_table</tt> - these global 
variables are the access points to the FIB tables; they point to table 
structures that point to hash tables that point to zones.  The contents 
of the <tt>main_table</tt> variable are in <i>/proc/net/route</i>.

</p><p>
FIB Table <tt>fib_table</tt> Structure - <i>include/net/ip_fib.h</i> - 
these structures contain function jump tables and each points to a hash 
table containing zone information.  There are usually only one or two of
 these.

</p><ul>

<li> <tt>int (*tb_<i>functions</i>)()</tt> - pointers to table functions (lookup, delete, insert, etc.) that are set during initialization to <tt>fn_hash_<i>function</i>()</tt>.

</li><li> <tt>unsigned char tb_data[0]</tt> - pointer to the associated FIB hash table (despite its declaration as a character array).

</li><li> <tt>unsigned char tb_id</tt> - table identifier; 255 for <tt>local_table</tt>, 254 for <tt>main_table</tt>.

</li><li> <tt>unsigned tb_stamp</tt>
</li></ul>
<p>
Netmask Table <tt>fn_hash</tt> Structure - <i>net/ipv4/fib_hash.c</i> - 
these structures contain pointers to the individual zones, organized by 
netmask.  (Each zone corresponds to a uniquely specific network mask.)  
There is one of these for each FIB table (unless two tables point to the
 same hash table).

</p><ul>

<li> <tt>struct fn_zone *fn_zones[33]</tt> - pointers to zone entries (one zone for each bit in the mask; <tt>fn_zone[0]</tt> points to the zone for netmask 0x0000, <tt>fn_zone[1]</tt> points to the zone for 0x8000, and <tt>fn_zone[32]</tt> points to the zone for 0xFFFF.

</li><li> <tt>struct fn_zone *fn_zone_list</tt> - pointer to first (most
 specific) non-empty zone in the list; if there is an entry for netmask 
0xFFFF it will point to that zone, otherwise it may point to zone 0xFFF0
 or 0xFF00 or 0xF000 etc.
</li></ul>
<p>
Network Zone <tt>fn_zone</tt> Structure - <i>net/ipv4/fib_hash.c</i> - 
these structures contain some hashing information and pointers to hash 
tables of nodes.  There is one of these for each known netmask.

</p><ul>

<li> <tt>struct fn_zone *fz_next</tt> - pointer to the next non-empty zone in the hash structure (the next most general netmask; e.g., <tt>fn_hash- &gt; fn_zone[28]- &gt; fz_next</tt> might point to <tt>fn_hash- &gt; fn_zone[27]</tt>).

</li><li> <tt>struct fib_node **fz_hash</tt> - pointer to a hash table of nodes for this zone.

</li><li> <tt>int fz_nent</tt> - the number of entries (nodes) in this zone.

</li><li> <tt>int fx_divisor</tt> - the number of buckets in the hash 
table associated with this zone; there are 16 buckets in the table for 
most zones (except the first zone - 0000 - the loopback device).

</li><li> <tt>u32 fz_hashmask</tt> - a mask for entering the hash table of nodes; 15 (0x0F) for most zones, 0 for zone 0).

</li><li> <tt>int fz_order</tt> - the index of this zone in the parent <tt>fn_hash</tt> structure (0 to 32).

</li><li> <tt>u32 fz_mask</tt> - the zone netmask defined as <tt><tt>~</tt>((1&lt;&lt;(32-fz_order))-1)</tt>;
 for example, the first (zero) element is 1 shifted left 32 minus 0 
times (0x10000), minus 1 (0xFFFF), and complemented (0x0000).  The 
second element has a netmask of 0x8000, the next 0xC000, the next 
0xE000, 0xF000, 0xF800, and so on to the last (32d) element whose mask 
is 0xFFFF.
</li></ul>
<p>
Network Node Information <tt>fib_node</tt> Structure - <i>net/ipv4/fib_hash.c</i>
 - these structures contain the information unique to each set of 
addresses and a pointer to information about common features (such as 
device and protocols); there is one for each known network (unique 
source/destination/TOS combination).

</p><ul>

<li> <tt>struct fib_node *fn_next</tt> - pointer to the next node.

</li><li> <tt>struct fib_info *fn_info</tt> - pointer to more information about this node (that is shared by many nodes).

</li><li> <tt>fn_key_t fn_key</tt> - hash table key - the least significant 8 bits of the destination address (or 0 for the loopback device).

</li><li> Other fields include specific information about this node (like <tt>fn_tos</tt> and <tt>fn_state</tt>).
</li></ul>
<p>
Network Protocol Information (<tt>fib_info</tt>) Structure - <i>include/net/ip_fib.h</i>
 - these structures contain protocol and hardware information that are 
specific to an interface and therefore common to many potential zones; 
several networks may be addressable through the same interface (like the
 one that leads to the rest of the Internet).  There is one of these for
 each interface.

</p><ul>

<li> <tt>fib_protocol</tt> - index to a network protocol (e.g., IP) used for this route.

</li><li> <tt>struct fib_nh fib_nh[0]</tt> - contains a pointer to the device used for sending or receiving traffic for this route.

</li><li> Other fields include list pointers and statistical and reference data (like <tt>fib_refcnt</tt> and <tt>fib_flags</tt>.
</li></ul>
<p>

</p><p><a name="tth_fIg8.4">
</a> <img src="linux-net_files/r_fib_struct.gif" alt="r_fib_struct.gif"><br> </p><center>Figure 8.4: Forwarding Information Base (FIB) data relationships.</center>
<a name="r_fib_struct">
</a>
<p>
</p><p>
<b>FIB Traversal Example:</b>

</p><ol type="1">

<li> <tt>ip_route_output_slow()</tt> (called because the route is not in the routing cache) sets up an <tt>rt_key</tt> structure with a source address of 172.16.0.7, a destination address of 172.16.0.34, and a TOS of 2.

</li><li> <tt>ip_route_output_slow()</tt> calls <tt>fib_lookup()</tt> and passes it the key to search for.

</li><li> <tt>fib_lookup()</tt> calls <tt>local_table- &gt; tb_lookup()</tt> (which is a reference to the <tt>fn_hash_lookup</tt> function) to make the local table find the key.

</li><li> <tt>fn_hash_lookup()</tt> searches the local table's hash 
table, starting in the most specific zone - 24 (netmask 255.255.255.0 
dotted decimal) (pointed to by the <tt>fn_zone_list</tt> variable).

</li><li> <tt>fz_key()</tt> builds a test key by ANDing the destination address with the zone netmask, resulting in a key value 172.16.0.0.

</li><li> <tt>fz_chain()</tt> performs the hash function (see <tt>fn_hash()</tt>) and ANDs this value with the zone's <tt>fz_hashmask</tt>
 (15) to get an index (6) into the zone's hash table of nodes.  
Unfortunately, this node is empty; there are no possible matches in this
 zone.

</li><li> <tt>fn_hash_lookup()</tt> moves to the next non-empty zone - 16 (netmask 255.255.0.0 dotted decimal) (pointed to by the current zone's <tt>fz_next</tt> variable).

</li><li> <tt>fz_key()</tt> builds a new test key by ANDing the destination address with this zone's netmask, resulting in a key value of 172.16.0.0.

</li><li> <tt>fz_chain()</tt> performs the hash function and ANDs this value with the zone's <tt>fz_hashmask</tt> (15) to get an index (10) into the zone's hash table of nodes.  There is a node in that slot.

</li><li> <tt>fn_hash_lookup()</tt> compares its search key to the 
node's key.  They do not match, but the search key value is less than 
that of the node key, so it moves on to the next node.

</li><li> <tt>fn_hash_lookup()</tt> compares its search key to the new 
node's key.  These do match, so it does some error checking and tests 
for an exact match with the node and its associated info variable.

</li><li> Since everything matches, <tt>fn_hash_lookup()</tt> fills in a <tt>fib_result</tt>
 structure with all the information about this route.  (Otherwise it 
would continue checking more nodes and more zones until it finds a match
 or fails completely.)

</li><li> <tt>ip_route_output_slow()</tt> takes the <tt>fib_result</tt> structure and, assuming everything is in order, creates a new routing cache entry from it.
</li></ol>
<p>
      </p><h3><a name="tth_sEc8.2.3">
8.2.3</a>&nbsp;&nbsp;The Routing Cache</h3>

<p><a name="tth_fIg8.5">
</a> 
<img src="linux-net_files/r_cache_gen.gif" alt="r_cache_gen.gif"><br>

 </p><center>Figure 8.5: Routing Cache conceptual organization.</center>
<a name="r_cache_gen">
</a>
<p>
</p><p>
The routing cache is the fastest method Linux has to find a route; it 
keeps every route that is currently in use or has been used recently in a
 hash table.  When IP needs a route, it goes to the appropriate hash 
bucket and searches the chain of cached routes until finds a match, then
 sends the packet along that path.  (See Section <a href="#sec_the_FIB">8.2.2</a>
 for what happens when the route is not yet in the cache.)  Routes are 
chained in order, most frequently used first, and have timers and 
counters that remove them from the table when they are no longer in use.
  See Figure&nbsp;<a href="#r_cache_gen">8.5</a> for an abstract overview and Figures&nbsp;<a href="#r_cache_struct">8.6</a>&nbsp;and&nbsp;<a href="#r_dst_struct">8.7</a> for detailed diagrams of the data structures.

</p><p>
<tt>struct rtable *rt_hash_table[RT_HASH_DIVISOR]</tt> - this global variable contains 256 buckets of (pointers to) chains of routing cache (<tt>rtable</tt>)
 entries; the hash function combines the source address, destination 
address, and TOS to get an entry point to the table (between 0 and 255).
  The contents of this table are listed in <i>/proc/net/rt_cache</i>.

</p><p>
Routing Table Entry (<tt>rtable</tt>) Structure - <i>include/net/route.h</i> - these structures contain the destination cache entries and identification information specific to each route.

</p><ul>

<li> <tt>union  &lt;  struct dst_entry dst; struct rtable* rt_next)  &gt;  u</tt> - this is an entry in the table; the union structure allows quick access to the next entry in the table by overusing the <tt>rtable</tt>'s next field to point to the next cache entry if required.

</li><li> <tt>__u32 rt_dst</tt> - the destination address.

</li><li> <tt>__u32 rt_src</tt> - the source address.

</li><li> <tt>rt_int iif</tt> - the input interface.

</li><li> <tt>__u32 rt_gateway</tt> - the address of the neighbor to route through to get to a destination.

</li><li> <tt>struct rt_key key</tt> - a structure containing the cache lookup key (with src, dst, iif, oif, tos, and scope fields)

</li><li> Other fields contain flags, type, and other miscellaneous information.
</li></ul>
<p>
Destination Cache (<tt>dst_entry</tt>) Structure - <i>include/net/dst.h</i> - these structures contain pointers to specific input and output functions and data for a route.

</p><ul>

<li> <tt>struct device *dev</tt> - the input/output device for this route.

</li><li> <tt>unsigned pmtu</tt> - the maximum packet size for this route.

</li><li> <tt>struct neighbor *neighbor</tt> - a pointer to the neighbor (next link) for this route.

</li><li> <tt>struct hh_cache *hh</tt> - a pointer to the hardware 
header cache; since this is the same for every outgoing packet on a 
physical link, it is kept for quick access and reuse.

</li><li> <tt>int (*input)(struct sk_buff*)</tt> - a pointer to the input function for this route (typically <tt>tcp_recv()</tt>).

</li><li> <tt>int (*output)(struct sk_buff*)</tt> - a pointer to the output function for this route (typically <tt>dev_queue_xmit()</tt>).

</li><li> <tt>struct dst_ops *ops</tt> - a pointer to a structure containing the family, protocol, and check, reroute, and destroy functions for this route.

</li><li> Other fields hold statistical and state information and links to other routing table entries.
</li></ul>
<p>
Neighbor Link (<tt>neighbor</tt>) Structure - <i>include/net/neighbor.h</i> - these structures, one for each host that is exactly one hop away, contain pointers to their access functions and information.

</p><ul>

<li> <tt>struct device *dev</tt> - a pointer to device that is physically connected to this neighbor.

</li><li> <tt>struct hh_cache *hh</tt> - a pointer to the hardware header that always precedes traffic sent to this neighbor.

</li><li> <tt>int (*output)(struct sk_buff*)</tt> - a pointer to the output function for this neighbor (typically <tt>dev_queue_xmit()</tt>?).

</li><li> <tt>struct sk_buff_head arp_queue</tt> - the first element in the ARP queue for traffic concerning this neighbor - incoming or outgoing?

</li><li> <tt>struct neigh_ops *ops</tt> - a pointer to a structure that containing family data and and output functions for this link.

</li><li> Other fields hold statistical and state information and references to other neighbors.
</li></ul>
<p>

</p><p><a name="tth_fIg8.6">
</a> <img src="linux-net_files/r_cache_struct.gif" alt="r_cache_struct.gif"><br> </p><center>Figure 8.6: Routing Cache data structure relationships.</center>
<a name="r_cache_struct">
</a>
<p>
</p><p>

</p><p><a name="tth_fIg8.7">
</a> <img src="linux-net_files/r_dst_struct.gif" alt="r_dst_struct.gif"><br> </p><center>Figure 8.7: Destination Cache data structure relationships.</center>
<a name="r_dst_struct">
</a>
<p>
</p><p>
<b>Routing Cache Traversal Example:</b>

</p><ol type="1">

<li> <tt>ip_route_output()</tt> (called to find a route) calls <tt>rt_hash_code()</tt> with a source address of 172.16.1.1, a destination address of 172.16.1.6, and a TOS of 2.

</li><li> <tt>rt_hash_code()</tt> performs a hash function on the 
source, destination, and TOS and ANDs the result with 255 to get an 
entry into the hash table (5).

</li><li> <tt>ip_route_output()</tt> enters the hash table at index 5.  There is an entry there, but the destination addresses do not match.

</li><li> <tt>ip_route_output()</tt> moves to the next entry (pointed to by the <tt>u.rt_next</tt> field of the last entry).  This one matches in every case - destination address, source address, <tt>iif</tt> of 0, matching <tt>oif</tt>, and acceptable TOS.

</li><li> <tt>ip_route_output()</tt> updates the statistics in the newfound <tt>dst_cache</tt>
 structure of the table entry, sets a pointer for the calling function 
to refer to the route, and returns a 0 indicating success.
</li></ol>
<p>
      </p><h3><a name="tth_sEc8.2.4">
8.2.4</a>&nbsp;&nbsp;Updating Routing Information</h3>
Linux only updates routing information when necessary, but the tables 
change in different manners.  The routing cache is the most volatile, 
while the FIB usually does not change at all.

<p>
The neighbor table changes as network traffic is exchanged.  If a host 
needs to send something to an address that is on the local subnet but 
not already in the neighbor table, it simply broadcasts an ARP request 
and adds a new entry in the neighbor table when it gets a reply.  
Periodically entries time out and disappear; this cycle continues 
indefinitely (unless a route has been specifically marked as ARP 
permanent).  The kernel handles most changes automatically.

</p><p>
The FIB on most hosts and even routers remains static; it is filled in 
during initialization with every possible zone to route through all 
connected routers and never changes unless one of the routers goes down.
  (See Chapter <a href="#dyn_route">9</a> for details on IP routing daemons).  Changes have to come through external <tt>ioctl()</tt> calls to add or delete zones.

</p><p>
The routing cache changes frequently depending on message traffic.  If a
 host needs to send packets to a remote address, it looks up the address
 in the routing cache (and FIB if necessary) and sends the packet off 
through the appropriate router.  On a host connected to a LAN with one 
router to the Internet, every entry will point to either a neighbor or 
the router, but there may be many entries that point to the router (one 
for each distant address).  The entries are created as connections are 
made and time out quickly when traffic to that address stops flowing.  
Everything is done with IP level calls to create routes and kernel 
timers to delete them.

</p><p>
        </p><h2><a name="tth_sEc8.3">
8.3</a>&nbsp;&nbsp;Linux Functions</h2>
The following is an alphabetic list of the Linux kernel functions that 
are most important to routing, where they are in the source code, and 
what they do.

<pre>arp_rcv() - net/ipv4/arp.c (542)
  checks for errors (non-ARP device, no device, packet not for host,
      device type does not match, etc.)
  check for operation - only understands REPLY and REQUEST
  extracts data from packet
  check for bad requests - loopback or multicast addresses
  checks for duplicate address detection packet (sends reply if necessary)
  if the message is a request and ip_route_input() is true:
    if the packet is a local one:
      calls neigh_event_ns() to look up and update neighbor that sent packet
      checks for hidden device (does not reply if hidden)
      sends reply with the device address
    otherwise:
      calls neigh_event_ns() to look up and update neighbor that sent packet
      calls neigh_release()
      if necessary, calls arp_send() with the address
      otherwise calls pneigh_enqueue() and returns 0
  if the message is a reply:
    calls __neigh_lookup()
    checks to see if multiple ARP replies have come in; keeps only the
        fastest (first) one
    calls neigh_update() to update ARP entry
	calls neigh_release()
  frees the skbuffer and returns 0

arp_send() - net/ipv4/arp.c (434)
  checks to make sure device supports ARP
  allocates an skbuffer
  fills in buffer header information
  fills in the ARP information
  calls dev_queue_xmit() with the finished packet

arp_req_get() - net/ipv4/arp.c (848)
  calls __neigh_lookup() to find entry for given address
  copies data from neighbor entry to arpreq entry
  returns 0 if found or ENXIO if address not in ARP table

fib_get_procinfo() - net/ipv4/fib_frontend.c (109)
  prints header and results of main_table-&gt;fn_hash_get_info() for proc FS

fib_lookup() - include/net/ip_fib.h (153)
  calls tb_lookup() [= fn_hash_lookup()] on local_table and main_table
  if either one has an entry, it fills in fib_result and returns 0
  else returns unreachable error

fib_node_get_info() - net/ipv4/fib_semantics.c (971)
  prints fib_node and fib_info contents for proc FS

fib_validate_source() - net/ipv4/fib_frontend.c (191)
  tests incoming packet's device and address
  returns error code if something is wrong
  returns 0 if packet seems legal

fn_hash() - net/ipv4/fib_hash.c (108)
  performs a hash function on a destination address:
    u32 h = ntohl(daddr)&gt;&gt;(32 - fib_zone-&gt;fz_order);
    h ^= (h&gt;&gt;20);
    h ^= (h&gt;&gt;10);
    h ^= (h&gt;&gt;5);
    h &amp;= FZ_HASHMASK(fz);   // FZ_HASHMASK is 15 for almost all zones

fn_hash_get_info() - net/ipv4/fib_hash.c (723)
  loops through zones in a FIB table printing fib_node_get_info() for
      proc FS

fn_hash_lookup() - net/ipv4/fib_hash.c (261)
  loops through the zones in the given table
    loops through the nodes in each zone (starting at the hash entry)
      if the netmasks (node and destination) match
          checks the TOS and node status
          calls fib_semantic_match() to check packet type
          fills in fib_result with success data and returns 0
  returns 1 if nothing matched

fn_new_zone() - net/ipv4/fib_hash.c (220)
  allocates memory (in kernel) for new zone
  allocates space for 16 node buckets for zone (except first zone -
      0.0.0.0 [loopback] - which only gets one)
  stores netmask (leftmost n bits on, where n is the position of the
      zone in the table)
  searches for more specific zone in parent table
  inserts zone into zone list (most specific zone is head)
  installs new zone into parent table
  returns new zone

fz_chain() - net/ipv4/fib_hash.c (133)
  calls fn_hash() to get a hash value
  returns the fib_node in the fib_zone at the hash index

ip_dev_find() - net/ipv4/fib_frontend.c (147)
  looks up and returns the device with a given address in the local table

ip_route_connect() - include/net/route.h (140)
  calls ip_route_output() to get a destination address
  returns if the call works or generates an error
  otherwise clears the route pointer and try again

ip_route_input() - net/ipv4/route.c (1366)
  calculates hash value for address
  runs through table (starting at hash) to find connection match
      (source, destination, TOS, and IIF/OIF)
  if there is a match, updates stats and returns routing entry
  else calls ip_route_input_slow()

ip_route_input_slow() - net/ipv4/route.c (1097)
  creates a routing table cache key
  checks for special addresses (like loopback, broadcast, or errors)
  calls fib_lookup() to find route
  allocates memory for new routing table entry
  initializes table entry with source, destination, TOS, output device,
      flags
  calls fib_validate_source() to test packet source
  printks message and returns error if source is bad
  calls rt_set_nexthop() to find next destination (neighbor)
  returns rt_intern_hash(), which installs route in routing table

ip_route_output() - net/ipv4/route.c (1664)
  calculates hash value for address
  runs through table (starting at hash) to find connection match
      (source, destination, TOS, and IIF/OIF)
  if there is a match, updates stats and returns routing entry
  else calls ip_route_output_slow()

ip_route_output_slow() - net/ipv4/route.c (1421)
  creates a routing table cache key
  if source address is known, calls ip_dev_find to determine output device
  if destination address is unknown, set up loopback
  calls fib_lookup() to find route
  allocates memory for new routing table entry
  initializes table entry with source, destination, TOS, output device,
      flags
  calls rt_set_nexthop() to find next destination (neighbor)
  returns rt_intern_hash(), which installs route in routing table

ip_rt_ioctl() - net/ipv4/fib_frontend.c (250)
  switches on SIOCADDRT or SIOCDELRT (returns EINVAL otherwise)
  verifies permission and copies argument to kernel space
  converts copied argument to an rtentry structure
  if deleting a route, calls fib_get_table() and table-&gt;delete()
  else calls fib_new_table() and table-&gt;insert()
  frees argument space and returns 0 for success

neigh_event_ns() - net/core/neighbour.c (760)
  calls __neigh_lookup() to find up address in neighbor table
  calls neigh_update()
  returns pointer to designated neighbor

neigh_update() - net/core/neighbour.c (668)
  checks permissions to modify table
  checks neighbor status if this is not a new entry
  compares given address to cached one:
    if null or device has no address, uses current address
    if different, check override flag
  calls neigh_sync() to verify neighbor is still up
  updates neighbor contact time
  if old entry was valid and new one does not change address, returns 0
  if new address is different from old, replaces old with new
  if new and old states match, returns 0
  calls neigh_connect() or neigh_suspect() to make/check connection
  if old state was invalid:
    goes through packets in ARP queue, calling the neighbor output()
        function on each
    purges the ARP queue
  returns 0

rt_cache_get_info() - net/ipv4/route.c (191)
  prints header and all elements of rt_hash_table for proc FS

rt_hash_code() - net/ipv4/route.c (18)
  uses source address, destination address, and type of service to
      determine (and return) a hash value:
    hash = ((daddr&amp;0xF0F0F0F0)&gt;&gt;4)|((daddr&amp;0x0F0F0F0F)&lt;&lt;4);
    hash = hash^saddr^tos;
    hash = hash^(hash&gt;&gt;16);
    hash = (hash^(hash&gt;&gt;8)) &amp; 0xFF;

rt_intern_hash() - net/ipv4/route.c (526)
  puts new route in routing table
</pre>

<p>
      </p><h1><a name="tth_chAp9">
Chapter 9     </a><br>Dynamic Routing with <i>routed</i></h1>
<a name="dyn_route">
</a>

<p>
This chapter presents dynamic routing as performed by a router (as 
opposed to an end host computer).  It provides an overview of how the <i>routed</i>
 program implements routing protocols under Linux, examines how it 
modifies the kernel routing tables, and summarizes the implementation 
code.

</p><p>
        </p><h2><a name="tth_sEc9.1">
9.1</a>&nbsp;&nbsp;Overview</h2>
A normal host computer has very limited options for routing packets; a 
message is either for itself or another computer, and if it is for 
another computer there are a very limited number of options for sending 
it on.  Usually such a host needs only to put a packet out on a LAN for a
 ``gateway'' computer (router) to pick up and send on its way.  Linux 
usually does not maintain any metric (distance) information about 
routes, even though there are variables for storing it in the FIB.  For 
simple end-host routing, the only important question is ``can I get 
there from here'', not ``which way is best?''

<p>
However, a router must make decisions on where to send traffic.  There 
may be several routes to a destination, and the router must select one 
(based on distance, measured in hops or some other metric such as the 
nebulous quality of service).  The Routing Information Protocol (RIP) is
 a simple protocol that allows routing computers to track the distance 
to various destinations and to share this information amongst 
themselves.

</p><p>
Using RIP, each node maintains a table that contains the distance from 
itself to other networks and the route along which it will send packets 
to that destination.  Periodically the routers update each other; when 
shorter routes becomes apparent, the node updates its table.  Updates 
are simply RIP messages with the destination address and metric 
components of this table.  See Figure&nbsp;<a href="#d_rip">9.1</a> for a diagram of an RIP routing table and an RIP packet.

</p><p><a name="tth_fIg9.1">
</a> 
<img src="linux-net_files/d_rip.gif" alt="d_rip.gif"><br>

 </p><center>Figure 9.1: Routing Information Protocol packet and table.</center>
<a name="d_rip">
</a>
<p>
</p><p>
        </p><h2><a name="tth_sEc9.2">
9.2</a>&nbsp;&nbsp;How <i>routed</i> Works</h2>
<i>routed</i> is a widely available program for implementing RIP via UDP
 messages on POSIX computers.  It is essentially a stand-alone program 
which uses <tt>ioctl()</tt> calls to get information from and update routing tables on the host machine.

<p>
      </p><h3><a name="tth_sEc9.2.1">
9.2.1</a>&nbsp;&nbsp;Data Structures</h3>
<i>routed</i> maintains two identical data tables - one for hosts and one for networks.  Each is a hash table with <tt>ROUTEHASHSIZ</tt> (32) buckets of chains of routing entries.  The entries contain the RIP information (but can also line up with a <tt>struct rtentry</tt> so that <i>routed</i> can pass them to the kernel through <tt>ioctl()</tt>
 calls).  Along with the basic destination, router, and metric 
information the entries store flags, state, and timer information.

<p>
      </p><h3><a name="tth_sEc9.2.2">
9.2.2</a>&nbsp;&nbsp;Initialization</h3>
When <i>routed</i> begins, it performs various initialization actions and calls <tt>ioctl()</tt>
 to get interface information from the kernel.  Next it sends out a 
RIP/UDP message requesting routing information from all neighboring 
routers.  Finally it enters an infinite loop in which it waits for 
traffic or timers to make it do something.

<p>
      </p><h3><a name="tth_sEc9.2.3">
9.2.3</a>&nbsp;&nbsp;Normal Operations</h3>
When RIP messages arrive (via a UDP socket), <i>routed</i> parses them 
and either modifies its table (for response messages) or sends 
information back to the requesting router (for requests).  Sending 
information is simply a matter of looking up a destination in its own 
table, putting that information into a RIP packet, and sending it out 
through a UDP socket.  Updating its table may have no impact (if there 
is no change or the change makes no difference) or it may result in a 
routing change.  If the update reveals a shorter route to a destination,
 <i>routed</i> will update its own table and then call <tt>ioctl()</tt> to update the kernel's routing tables (the FIB).

<p>
When the update timer expires, every <tt>TIMER_RATE</tt> seconds, <i>routed</i>
 goes through every entry in both tables and updates their timers.  
Entries which are out of date are set to a distance of infinity (<tt>HOPCNT_INFINITY</tt>)
 and entries which are too old are deleted (only from the RIP table, not
 from the kernel's FIB).  Finally, it sends an update to its neighboring
 routers.  This update contains the new table information (response 
messages) for any entries which have changed since the last update.

</p><p>
<i>routed</i> leaves the actual routing to the normal kernel routing 
mechanisms; all it does is update the kernel's tables based on 
information from other routers and pass on its own routing information. 
 The updates then change how the kernel routes packets, but <i>routed</i> itself does not actually do any routing.

</p><p>
        </p><h2><a name="tth_sEc9.3">
9.3</a>&nbsp;&nbsp;<i>routed</i> Functions</h2>
The following is an alphabetic list of the <i>routed</i> program functions that are most important to routing, where they are in the source code, and what they do.  The <i>SOURCES</i> directory shown represents the directory that contains the source code for the given network file.

<p>
The <i>routed</i> source is available as a package separate from the kernel source (Red Hat Linux uses the <i>rpm</i> package manager).  The code below is from the <i>netkit-routed-0.10</i> source code package, 8 March 1997.  This package is available from the <i>www.redhat.com/apps/download</i> web page; specifically this came from <i>www.redhat.com/swt/src/netkit-routed-0.10.src.html</i>.  Once downloaded, <i>root</i> can install the package with the following commands (starting from the directory with the package):

</p><blockquote><tt>
rpm -i netkit-routed-0.10.src.rpm<br>
cd /usr/src/redhat/SOURCES<br>
tar xzf netkit-routed-0.10.tar.gz</tt>
</blockquote>
This creates a <i>/usr/src/redhat/SOURCES/netkit-routed-0.10</i> directory and fills it with the source code for the <i>routed</i> program.  This process should be similar (but is undoubtably not exactly the same) for other Linux distributions.

<p>

</p><pre>ifinit() - SOURCES/routed/startup.c (88)
  opens a UDP socket
  calls ioctl(SIOCFIGCONF) to get interface configuration
  loops through interfaces:
    calls ioctl() to get flags, broadcast address, metric, and netmask
    creates a new interface structure
    copies info into interface structure
    calls addrouteforif() to add routing entry for interface
  sets supplier variable if necessary
  closes socket

process() - SOURCES/routed/main.c (298)
  starts a continuous loop:
    receives a packet (waits)
    verifies that packet is correct size
    calls rip_input() to handle (RIP) packet

rip_input() - SOURCES/routed/input.c (60)
  traces input if necessary
  checks packet to make sure protocol and address are supported
  checks for RIP version (cannot be 0)
  switch based on packet content - 
    if packet is a request:
      checks request for validity
      if request is for all entries, calls supply()
      else looks up requested address, builds and sends response packet
    if packet is a trace on or off:
      verifies request came from a valid port
      if all is in order, sets trace to on or off
    if packet is a response:
      verifies response came from a router
      updates timer for interface
      loops through each entry in received packet:
        parses route information
        validates address family, host, and metric information
        updates hop count (adds metric in message to hop count to router
            that send message, subject to HOPCNT_INFINITY maximum)
        calls rtlookup() to find address in routing table 
        if this seems to be a new route:
           calls rtfind() to look for an equivalent route
           if it really is new, calls rtadd() and returns
        calls rtchange() to modify route if necessary (new route or
           hopcount change)
        updates route timers
  if there were changes:
    sends an update if neccessary
    updates general update timer information

&gt;&gt;&gt; routed main() - SOURCES/routed/main.c (78)
  opens routed log file
  calls getservbyname() to get UDP router
  sets up a UDP socket for RIP message traffic
  runs through command line arguments to set flags
  if not debugging, forks and runs program in new session (parent dies)
  calls rtinit() to initialize data tables
  calls ifinit() to fill in interface information
  calls toall() to request info from all other routers
  installs signal handlers for ALRM,HUP,TERM,INT,USR1,and USR2
  starts a continuous loop:
    if in need of update, sets up timer variables
    calls select() to wait for traffic
    if select() returns an error (other than EINTR), logs it
    if select() times out (time for update)
        calls toall() to broadcast update
        resets timer variables
    if there is traffic waiting on the socket, calls process()

rtadd() - SOURCES/routed/tables.c (138)
  verifies address family is in proper range
  calls family af_rtflags() function to set routing flags
  determines hash value for appropriate table (host or net)
  creates and fills in new rt_entry structure
  calls insque() to add entry to table
  calls rtioctl() to add entry to kernel table
  if call fails:
    if route should work, calls family af_format() to add destination
        and gateway to kernel tables
    if host is unreachable, removes and frees entry

rtchange() - SOURCES/routed/tables.c (207)
  determines if change necessitates adding or deleting gateways
  calls rtioctl() to add and/or delete routes

rtfind() - SOURCES/routed/tables.c (100)
  determines hash value for host table
  loops through table; returns entry if addresses are equal
  determines hash value for net table
  goes back to loop through table, this time returning entry if a call
      to family af_netmatch() function returns true
  returns null (0) if no match

rtinit() - SOURCES/routed/tables.c (336)
  loops through the net hash table, setting forward and back pointers
  loops through the host hash table, setting forward and back pointers

rtioctl() - SOURCES/routed/tables.c (346)
  fills in rtentry structure from parameters
  outputs trace actions if necessary
  calls ioctl(SIOCADDRT or SIOCDELRT) to update kernel table
  returns result of ioctl() call (or -1 for erroneous parameter)

rtlookup() - SOURCES/routed/tables.c (65)
  determines hash value for address
  runs through host table looking for match
  if unsuccessful at first, tries again with net table
  returns pointer to entry or null (0)

sndmsg() - SOURCES/routed/output.c (77)
  calls the appropriate family output function
  traces the packet if necessary

supply() - SOURCES/routed/ouput.c (91)
  creates an RIP response message
  loops through the routing host table
    loops through the routing entries
      checks to see if routing host needs the entry
      if so, puts routing info into packet and sends it
  goes back and does it again with the routing net table

timer() - SOURCES/routed/timer.c (56)
  updates timer variables
  loops through the host table
    updates timer information for each entry
    deletes entry if it is too old
    changes metric to infinity if it is getting old
  goes back and does it again with net table
  calls toall() if update is due

toall() - SOURCES/routed/output.c (55)
  loops through interfaces:
    sets destination address to broadcast or specific address
    calls passed function [sndmsg() or supply()] with address
</pre>

<p>
      </p><h1><a name="tth_chAp10">
Chapter 10     </a><br>Editing Linux Source Code</h1>

<p>
        </p><h2><a name="tth_sEc10.1">
10.1</a>&nbsp;&nbsp;The Linux Source Tree</h2>
Linux source code is usually in the /usr/src directory (if installed).  
There may be many versions in different directory trees (such as <i>linux-2.2.5</i> or <i>linux-2.2.14</i>).  There should be one soft link (<i>linux</i>) to the most current version of the code (i.e. <i>linux <font face="symbol"></font> linux-2.2.14</i>).

<p>
This is an overview of the Linux source directory structure (not all branches are shown:

</p><p>
<i>/usr/src/linux/</i>

</p><p>

</p><ul>
<li> <i>arch</i> - architecture specific code, by processor
	
<ul>
	
<li> <i>i386</i> - code for Intel processors (including 486 and Pentium lines)
		
<ul>
			
<li> <i>boot</i> - location of newly compiled kernels
		</li></ul>
<p>
	</p></li></ul>
</li><li> <i>drivers</i> - code for drivers of all sorts
	
<ul>
	
<li> <i>block</i> - block device drivers (e.g., hard drives)
	
</li><li> <i>cdrom</i> - CD ROM device drivers
	
</li><li> <i>net</i> - network device drivers
	
</li><li> <i>pci</i> - PCI bus drivers
	</li></ul>
<p>

</p></li><li> <i>fs</i> - code for different file systems (EXT2, MS-DOS, etc.)

</li><li> <i>include</i> - header files used throughout the code
	
<ul>
	
<li> <i>asm <font face="symbol"></font> asm-i386</i> - processor dependent headers
	
</li><li> <i>config</i> - general configuration headers
	
</li><li> <i>linux</i> - common headers
	
</li><li> <i>net</i> - networking headers
	</li></ul>
<p>

</p></li><li> <i>kernel</i> - code for the kernel specific routines

</li><li> <i>lib</i> - code for errors, strings, and printf

</li><li> <i>mm</i> - code for memory management

</li><li> <i>modules</i> - object files and references for the kernel to load as required

</li><li> <i>net</i> - code for networking
	
<ul>
	
<li> <i>core</i> - protocol independent code
	
</li><li> <i>ipv4</i> - code specific to IPv4
	
</li><li> <i>packet</i> - protocol independent packet code
	
</li><li> <i>sched</i> - code for scheduling network actions
	</li></ul>
<p>
</p></li></ul>        <h2><a name="tth_sEc10.2">
10.2</a>&nbsp;&nbsp;Using EMACS Tags</h2>
The Linux source is obviously very large and spread throughout many files.  A <i>TAGS</i> file allows you to quickly maneuver to a specific file in search of a reference.

<p>
      </p><h3><a name="tth_sEc10.2.1">
10.2.1</a>&nbsp;&nbsp;Referencing with TAGS</h3>
Inside a file, move the cursor to a keyword you would like to look up 
(e.g., ``sock'').  Press ``ESC'' ``.'' - EMACS will prompt for the tag 
to find (defaulting to the word your cursor is on);  hit ``ENTER''.  The
 first time you use it, you will have to specify which TAGS file to use 
(e.g., <i>/usr/src/TAGS</i>).  Next   EMACS will automatically open the appropriate file (e.g., <i>/usr/src/linux/include/linux/sock.h</i>)
 in a new buffer and put the cursor on the definition of that struct, 
#define, or function.  If the definition it brings up is not the one you
 were looking for, press ``CTRL-U'' ``ESC'' ``.'' to bring up alternate 
references.

<p>
These tags work even as you make changes to the source files, though 
they will run slower as more and more changes are made.  EMACS stores 
the tags in a file (defaulted to <i>TAGS</i>) with each reference, 
filename, and line number.  If the tag is not at the stored line number,
 EMACS will search the file to find the new location.

</p><p>
      </p><h3><a name="tth_sEc10.2.2">
10.2.2</a>&nbsp;&nbsp;Constructing TAGS files</h3>
If you need to start from scratch, follow the steps below.

<p>
The command to make a tags file is:

</p><blockquote>
<tt>etags</tt> <i>filename</i>
</blockquote>
The command to append new information onto a tags file is:

<blockquote>
<tt>etags -a</tt> <i>filename</i>
</blockquote>
These put the new tags into the file <i>TAGS</i> in the current 
directory.  Filenames are stored as given, so absolute references will 
always refer to the same files while relative references depend on the 
position of the <i>TAGS</i> file.  (Read the man page for <i>etags</i> for more information).

<p>
For example, to create a tags file for the <i>ipv4</i> source files, enter:

</p><blockquote>
<tt>etags /usr/src/linux/net/ipv4/*.c</tt>
</blockquote>
To add the header files, enter:

<blockquote>
<tt>etags -a /usr/src/include/net/*.h</tt>
</blockquote>
The <i>TAGS</i> file will now contain quick references to all the C source code and header information in those directories.

<p>
        </p><h2><a name="tth_sEc10.3">
10.3</a>&nbsp;&nbsp;Using vi tags</h2>
The vi editor also supports the use of tags files (and creates them with the <i>gctags</i> command, which works almost exactly like the <i>etags</i> command shown above).

<p>
        </p><h2><a name="tth_sEc10.4">
10.4</a>&nbsp;&nbsp;Rebuilding the Kernel</h2>
(See the Linux-kernel-HOWTO for more detailed instructions.)

<p>
This is a quick step-by-step guide to recompiling and installing a kernel from scratch.

</p><p>

</p><ol type="1">
<li> Go to the top of the source directory (<i>/usr/src/linux</i>).  If there is not already a historical copy of a working <i>.config</i>
 file (such as the current one), MAKE ONE.  Until you have enough 
experience that you no longer need this guide, do not overwrite anything
 until you have made sure there is a copy to which you can revert.  (On 
the other hand, once you have a stable kernel version, there is no 
reason to keep old ones around.  Even a development system should 
probably only have an original working version, a last known stable 
version, and a current version.

<p>

</p></li><li> Run <tt>make xconfig</tt> (<tt>make config</tt> and <tt>make menuconfig</tt>
 also work, but xconfig is by far the user-friendliest).  Configure the 
system as desired; there is help available for most options.  The config
 file should default to the current settings, so you should only have to
 change the things you want to add or take out.  As a general rule, 
select ``Y'' for essential or frequently used features (like the ext2 
file system), ``M'' for things that are sometimes useful (like sound 
drivers), and ``N'' for things that do not apply (like amateur radio 
support).  If in doubt, consult the help text or include something as a 
module.

<p>

</p></li><li> Run <tt>make dep</tt> to make sure the options you heve 
selected will compile properly.  This make take a few minutes as the 
computer checks all of the dependencies.  If all goes well, the <tt>make</tt> program will simply exit; if there is a problem, it will display error messages and stop.

<p>

</p></li><li> Run <tt>make clean</tt> to remove old object files IF you want to recompile everything.  This obviously will make the compilation process take longer.

<p>

</p></li><li> Run <tt>make bzImage</tt> to build the new kernel.  (<tt>make zImage</tt> and <tt>make boot</tt>
 also build kernel images, but the bzImage will compile into the most 
compact file.  If you are using one of these two methods for some 
reason, you may get a ``kernel too big'' error when you run <i>lilo</i> - try again with a <tt>bzImage</tt>.)  This will take quite some time, depending on available memory.

<p>

</p></li><li> Run <tt>make modules</tt> to build any modules (not included in the main kernel image).

<p>

</p></li><li> Rename the old modules if necessary:

<blockquote>
<tt>mv /lib/modules/2.2.xx /lib/modules/2.2.xx-old</tt>
</blockquote>
(Note that you will not have to do this if you are compiling a completely new version; the old ones will still be in <i>/lib/modules/2.2.xx</i> when you build version 2.2.<i>yy</i>.)

<p>

</p></li><li> Run <tt>make modules_install</tt> to install the new 
modules.  You must do this even if you built a monolithic kernel (one 
with no modules).  (Note that there may be a Red Hat <i>module-info</i> text file or link in the boot directory; it is not terribly important and this does not update it.)

<p>

</p></li><li> Copy the new kernel to the <i>/boot</i> directory and change the kernel link (usually <i>vmlinuz</i>):

<blockquote>
<tt>cp arch/i386/boot/bzImage /boot/vmlinuz-2.2.xx</tt><br>
<tt>ln -sf /boot/vmlinuz-2.2.xx /boot/vmlinuz</tt>
</blockquote>

<p>

</p></li><li> Copy the new <i>System.map</i> file to the <i>/boot</i> directory and change the map link:

<blockquote>
<tt>cp System.map /boot/System.map-2.2.xx</tt><br>
<tt>ln -sf /boot/System.map-2.2.xx /boot/System.map</tt>
</blockquote>

<p>

</p></li><li> Create a new <i>initrd</i> file if there are any SCSI devices on the computer:

<blockquote>
<tt>/sbin/mkinitrd /boot/initrd-2.2.xx.img 2.2.xx</tt>
</blockquote>

<p>

</p></li><li> Edit the file <i>/etc/lilo.conf</i> to install the new kernel; copy the block for the old kernel (<tt>image=vmlinuz</tt>) and change the existing one to keep it as an option.  For example, rename the image to <tt>vmlinuz-2.2.xx-old</tt> and change the label to <tt>stable</tt>.  This way you can always reboot to the current (presumably stable) kernel if your changes cause problems.

<p>

</p></li><li> Run <tt>/sbin/lilo</tt> to install the new kernel as a boot option.

<p>

</p></li><li> Reboot the computer with the new kernel.

<p>

</p></li><li> If the new kernel does not work properly, boot the old kernel and reconfigure the system before trying again.

<p>
</p></li></ol>        <h2><a name="tth_sEc10.5">
10.5</a>&nbsp;&nbsp;Patching the Kernel Source</h2>

<p>
Linux is a constantly changing operating system; updates can be released
 every few months.  There are two ways to install a new kernel version: 
downloading the new source in its entirety or downloading patches and 
applying them.

</p><p>
Downloading the entire source may be preferable to guarantee everything 
works properly.  To do so, download the latest kernel source and install
 (<i>untar</i>) it.  Note that this will (probably) be a complete 
distribution, not a machine-specific one, and will contain a lot of 
extra code.  Much of this can be deleted, but the configuration 
Makefiles rely on some for information.  If space is an issue, delete 
the <i>*.c</i> and <i>*.h</i> files in the non-i386 <i>arch/</i> and <i>include/asm-*</i> directories, but tread lightly.

</p><p>
Downloading patches may be quicker to do, but is somewhat harder.  
Because of distribution variations, changes you have made, or other 
modifications the patches may not quite work properly.  You must apply 
patch files in order (to go from 2.2.12 to 2.2.14, first apply patch 
2.2.13 then apply 2.2.14).  Nevertheless, patches may be preferable 
because they work on an existing directory tree.

</p><p>
Once you have downloaded a patch (and unzipped it, if necessary), simply put it in the directory above <i>linux</i> (e.g., <i>/usr/src/</i>) and run the patch program to install it:

</p><blockquote>
<tt>patch -Np0 -verbose -r rejfile  &lt;  patch-2.2.xx</tt>   <i>(where xx is the patch version)</i>
</blockquote>
The <tt>-N</tt> option ignores patches that are already applied, and the <tt>-p0</tt> assumes the patch wants to apply itself to a source in a <i>linux</i> directory.  The <tt>-r rejfile</tt> option puts all the patch rejects into one file (<i>rejfile</i>)
 - which may or may not be what you want to do.  If you have not kept 
the entire source distribution, you will have to skip many changes (for 
different processor architectures) by simply hitting ``ENTER'' at the 
``patch which file'' and ``ignore patch'' prompts.  Once you are 
comfortable with the process, run it without the <tt>-verbose</tt> and <tt>-r rejfile</tt> options.

<p>
Once you have a new kernel version, follow the instructions on 
rebuilding the kernel to actually start using it.  You probably will not
 have to change any of the configurations options, but you will almost 
definitely want to run <tt>make clean</tt> to remove any old object files.

</p><p>
      </p><h1><a name="tth_chAp11">
Chapter 11     </a><br>Linux Modules</h1>
<a name="module">
</a>

<p>
This chapter presents the Linux module system.  It provides an overview 
of how modules work, describes how to install and remove them, and 
presents an example program.

</p><p>
        </p><h2><a name="tth_sEc11.1">
11.1</a>&nbsp;&nbsp;Overview</h2>
Linux kernels more recent than 2.0 can be (and usually) are modularized.
  There is a portion of the kernel that remains in memory constantly 
(the most frequently used processes, such as the scheduler) but other 
processes are only loaded when needed.  An MS-DOS file system for 
reading disks, for example, might be loaded only on mounting such a disk
 and then unloaded when no longer needed.  This keeps the space the 
kernel requires at any one time small while allowing it to do more and 
more.  It is still possible to put everything into one ``monolithic'' 
kernel that will not need modules, but that is usually done only for 
special purpose machines (where all the required processes are known in 
advance).

<p>
Another advantage of modules is that the kernel can load and unload them dynamically (and automatically with the <i>kerneld</i>
 daemon).  This means that a (super) user can load a module, test it, 
unload it, and debug it repeatedly without having to reboot the 
computer.  This document assumes that the user has superuser access (you
 must be <tt>root</tt> to install and remove modules) and the kernel is 
configured for modules.  (With a monolithic kernel, it is possible to 
set configuration options not to even allow modules.)

</p><p>
        </p><h2><a name="tth_sEc11.2">
11.2</a>&nbsp;&nbsp;Writing, Installing, and Removing Modules</h2>

<p>
      </p><h3><a name="tth_sEc11.2.1">
11.2.1</a>&nbsp;&nbsp;Writing Modules</h3>
Modules are just like any other programs except that they run in kernel space.  As such, they must define <tt>MODULE</tt> and include <i>module.h</i>
 and any other kernel header files that define functions or variables 
they use.  Modules can be quite simple (as the example shows) but they 
can also be quite complex, such as device drivers and entire file 
systems.

<p>
This is the general module format:

</p><pre>#define MODULE
#include &lt;linux/module.h&gt;
/* ... other required header files ...  */

/*
 *  ... module declarations and functions ...
 */

int init_module() {
  /* code kernel will call when installing module */
}

void cleanup_module() {
  /* code kernel will call when removing module */
}
</pre>

<p>
Modules that use the kernel source must be compiled with <i>gcc</i> with the option <tt>-I/usr/src/linux/include</tt>; this ensures that the files included will be from the proper source tree.

</p><p>
Note that not all kernel variables are exported for modules to use, even if the code declares them to be <tt>extern</tt>.  The <i>/proc/ksyms</i> file or <i>ksyms</i>
 program display the exported symbols (not many of which are useful for 
networking).  Recent Linux kernels export both the symbol and its 
version number using the <tt>EXPORT_SYMBOL(x)</tt> macro.  For user created variables, use the <tt>EXPORT_SYMBOL_NOVERS(x)</tt> macro instead or the linker will not retain the variable in the kernel symbol table.  Module writers may also want to use the <tt>EXPORT_NO_SYMBOLS</tt> macro; modules export all of their variables by default.

</p><p>
      </p><h3><a name="tth_sEc11.2.2">
11.2.2</a>&nbsp;&nbsp;Installing and Removing Modules</h3>
Installing and removing modules is as simple as calling a program with 
the name of the compiled module.  (You must be a superuser to install or
 remove a module.)

<p>
The <i>insmod</i> program installs a module; it first links the module 
with the kernel's exported symbol table to resolve references and then 
installs the code in kernel space.

</p><blockquote>
<tt>/sbin/insmod</tt> <i>module_name</i>
</blockquote>

<p>
The <i>rmmod</i> program removes an installed module and any references that it has exported.

</p><blockquote>
<tt>/sbin/rmmod</tt> <i>module_name</i>
</blockquote>

<p>
The <i>lsmod</i> program lists all the currently installed modules:

</p><pre>    /sbin/lsmod
    Module       Size  Used by
    cdrom       13368   0 (autoclean) [ide-cd]
    3c59x       19112   1 (autoclean)
</pre>

<p>
        </p><h2><a name="tth_sEc11.3">
11.3</a>&nbsp;&nbsp;Example</h2>
This is a complete example of a very simple module.

<p>
<i>simple_module.c</i>

</p><pre>/* simple_module.c
 *
 * This program provides an example of how to install a trivial module
 *   into the Linux kernel.  All the module does is put a message into
 *   the log file when it is installed and removed.
 *
 */

#define MODULE
#include &lt;linux/module.h&gt;
/* kernel.h contains the printk function */
#include &lt;linux/kernel.h&gt;

/*************************************************************** init_module
 * the kernel calls this function when it loads the module */
int init_module() {
  printk("&lt;1&gt;The simple module installed itself properly.\n");
  return 0;
}  /* init_module */

/************************************************************ cleanup_module
 * the kernel calls this function when it removes the module */
void cleanup_module() {
  printk("&lt;1&gt;The simple module is now uninstalled.\n");
}  /* cleanup_module */
</pre>

<p>
This is the <i>Makefile</i>:

</p><pre># Makefile for simple_module

CC = gcc -I/usr/src/linux/include/config

CFLAGS = -O2 -D__KERNEL__ -Wall

simple_module.o: simple_module.c

install:
	/sbin/insmod simple_module

remove:
	/sbin/rmmod simple_module
</pre>

<p>
To use (must be <tt>root</tt>):

</p><pre>root# make
root# make install
root# make remove
root# tail /var/log/messages
... kernel: The simple module installed itself properly.
... kernel: The simple module is now uninstalled.
</pre>

<p>
      </p><h1><a name="tth_chAp12">
Chapter 12     </a><br>The <i>proc</i> File System</h1>
<a name="proc_system">
</a>

<p>
This chapter presents the virtual <i>proc</i> file system.  It provides 
an overview of how the file system works, shows how the existing network
 code uses the system, and details how to write and use <i>proc</i> entries from programs.

</p><p>
        </p><h2><a name="tth_sEc12.1">
12.1</a>&nbsp;&nbsp;Overview</h2>
The <i>proc</i> file system is so named because it is found in the <i>/proc</i> directory on most Linux machines.  NOT including the <i>proc</i>
 FS is a configuration option, but the system is a powerful tool of 
which many programs make frequent use.  While designed to appear as a 
file system with directory structures and inodes, it is in fact a 
construct of registered functions which provide information about 
important variables.

<p>
The <i>proc</i> directory has many subdirectories - one for each running
 process and others for subsystems such as file systems, interfaces, 
terminals, and networking (<i>/proc/net</i>).  There are also many files in the main <i>/proc</i> directory itself - <i>interrupts</i>, <i>ioports</i>, <i>loadavg</i>, and <i>version</i>
 to name a few.  Within each process subdirectory (named for the process
 number) are files that describe the process' command line, current 
working directory, status, and so on.

</p><p>
The kernel traps <i>proc</i> file access and instead of executing 
``normal'' file operations on them calls special (individually 
registered) functions instead.  When a file in the <i>/proc</i> 
directory is ``created'', it is registered with a set of functions that 
tell the kernel what to do when the file is read from or written to.  
Most entries only allow reads and they simply print out the state of 
certain system variables for use by other programs or for perusal by 
knowledgeable users.

</p><p>
The only tricky thing about using <i>proc</i> files is that the kernel 
calls the information generation function each and every time the file 
is read; subsequent reads of a changing file without copying and 
buffering the results may yield very different results.  The best way to
 use a <i>proc</i> file is to read it into a <tt>PAGE_SIZE</tt>-byte buffer.  This will read the entire entry at once and the buffer will then allow consistent random accesses.

</p><p>
        </p><h2><a name="tth_sEc12.2">
12.2</a>&nbsp;&nbsp;Network <i>proc</i> Files</h2>
This is a list of the most important files in the <i>/proc/net/</i> 
directory, what they contain, and a reference to the function and file 
that creates them.  Note that there are many other interesting <i>proc</i> entries, such as the <i>/proc/sys</i> files, <i>/proc/ksyms</i>, and <i>/proc/modules</i> to name only a few.

<dl compact="compact">
<dt><b><i>arp</i></b></dt>
	<dd> displays the neighbor table (<tt>arp_tbl</tt>); the IP and hardware addresses, hardware type, device, and flags.  (<tt>arp_get_info()</tt> : <i>net/ipv4/arp.c</i> 988)
</dd><dt><b><i>dev</i></b></dt>
	<dd> displays reception and transmission statistics for each registered interface
</dd><dt><b><i>dev_stat</i></b></dt>
	<dd> displays number of received packets dropped and throttle and FASTROUTE statistics (<tt>dev_proc_stats()</tt> : <i>net/core/dev.c</i> 1228)
</dd><dt><b><i>netstat</i></b></dt>
	<dd> displays sync cookie, pruning, and ICMP statistics (<tt>netstat_get_info()</tt> : <i>net/ipv4/proc.c</i> 355)
</dd><dt><b><i>raw</i></b></dt>
	<dd> displays address, queue, and timeout information for each open RAW socket from <tt>struct proto raw_prot</tt> (<tt>get__netinfo()</tt> : <i>net/ipv4/proc.c</i> 165)
</dd><dt><b><i>route</i></b></dt>
	<dd> displays the FIB table (<tt>main_table</tt>); the interface, address, gateway, flags, and usage information.  (<tt>fib_get_procinfo()</tt>) : <i>net/ipv4/fib_frontend.c</i> 109)
</dd><dt><b><i>rt_cache</i></b></dt>
	<dd> displays the routing cache (<tt>rt_hash_table</tt>); the interface, address, gateway, usage, source, and other information.  (<tt>rt_cache_get_info()</tt> : <i>net/ipv4/route.c</i> 191)
</dd><dt><b><i>sockstat</i></b></dt>
	<dd> displays number of sockets that have been used and some statistics on how many were TCP, UDP, and RAW (<tt>afinet_get_info()</tt> : <i>net/ipv4/proc.c</i> 244)
</dd><dt><b><i>tcp</i></b></dt>
	<dd> displays address, queue, and timeout information for each open TCP socket from <tt>struct proto tcp_prot</tt> (<tt>get__netinfo()</tt> : <i>net/ipv4/proc.c</i> 165)
</dd><dt><b><i>udp</i></b></dt>
	<dd> displays address, queue, and timeout information for each open UDP socket from <tt>struct proto udp_prot</tt> (<tt>get__netinfo()</tt> : <i>net/ipv4/proc.c</i> 165)
</dd></dl>
<p>
        </p><h2><a name="tth_sEc12.3">
12.3</a>&nbsp;&nbsp;Registering <i>proc</i> Files</h2>
This section describes the simplest method for registering a read-only <i>proc</i>
 ``file'' entry (available only in Linux 2.0 and later releases).  It is
 possible to create a more fully functional entry by defining <tt>file_operations</tt> and <tt>inode_operations</tt>
 structures.  However, that method is significantly more complicated 
than the one presented here; look in the source code for details on 
implementing fully functional entry.  The method described below - 
defining a function and then registering and unregistering the function -
 provides most of the functionality required for testing and tracking 
system resources.  Only the kernel can register a <i>proc</i> file; users can do so by building and installing kernel modules (though only <tt>root</tt>
 can install and remove modules).  These procedures assume that the 
Linux source is installed and the kernel is compiled to use modules.

<p>
      </p><h3><a name="tth_sEc12.3.1">
12.3.1</a>&nbsp;&nbsp;Formatting a Function to Provide Information</h3>

<p>
<tt>static int</tt> <i>read_proc_function</i><tt>(char *buf,char **start,off_t offset,int len,int unused)</tt>

</p><p>
This is the function that the Linux kernel will call whenever it tries to read from the newly created <i>proc</i> ``file''.  The only parameter that is usually significant is <tt>buf</tt> - a pointer to the buffer the kernel makes available for storing information.  The others normally will not change.  (<i>read_proc_function</i> is of course the name of the new function.)

</p><p>
Typically this function prints out a header, iterates through a list or table printing its contents (using the normal <tt>sprintf</tt> routine), and returns the length of the resulting string.  The only limitation is that the buffer (<tt>buf</tt>) is at most <tt>PAGE_SIZE</tt> bytes (this is at least 4KB).

</p><p>
For an example of this kind of function, look at the <tt>fib_get_procinfo()</tt> function beginning on line 109 of <i>net/ipv4/fib_frontend.c</i>.  This function displays the contents of the main FIB table.

</p><p>
      </p><h3><a name="tth_sEc12.3.2">
12.3.2</a>&nbsp;&nbsp;Building a <i>proc</i> Entry</h3>
Because this is part of the file system, the entry needs an inode.  This is easily constructed using a <tt>struct proc_dir_entry</tt>:

<pre>#include &lt;linux/proc_fs.h&gt;
struct proc_dir_entry new_proc_entry = {
   0,                     // low_ino - inode number (0 for dynamic)
   5,                     // namelen  - length of entry name
   "entry",               // name
   S_IFREG | S_IRUGO,     // mode
   1,                     // nlinks
   0,                     // uid - owner
   0,                     // gid - group
   0,                     // size - not used
   NULL,                  // ops - inode operations (use default)
   &amp;read_proc_function    // read_proc - address of read function
                          // leave rest blank!
}
</pre>
The contents of this block can be used as shown by simply replacing the <tt>namelen</tt>, <tt>name</tt>, and <tt>read_proc_function</tt> fields with the desired values.  Note that many of the kernel defined entries have predefined inode numbers (like <tt>PROC_NET_ROUTE</tt>, part of an enumeration defined in <i>include/linux/proc_fs.h</i>.

<p>
For an example of this kind of entry, look at the <tt>__init_func()</tt> function beginning on line 607 of <i>net/ipv4/fib_frontend.c</i>.  This functions calls <tt>proc_net_register()</tt> (described below) with a newly created <tt>proc_dir_entry</tt> structure.

</p><p>
      </p><h3><a name="tth_sEc12.3.3">
12.3.3</a>&nbsp;&nbsp;Registering a <i>proc</i> Entry</h3>
Once the read function and the inode entry are ready, all that remains is to register the new ``file'' with the <i>proc</i> system.

<p>
<tt>int proc_register(struct proc_dir_entry *dir, struct proc_dir_entry *entry)</tt><br>
<tt>int proc_net_register(struct proc_dir_entry *entry)</tt>

</p><p>
<tt>dir</tt> is a pointer to the directory in which the entry belongs - <tt>&amp;proc_root</tt> and <tt>proc_net</tt> (defined in <i>include/proc_fs.h</i>) are probably the most useful.  <tt>entry</tt> is a pointer to the entry itself, as created above.  These two functions are identical except that <tt>proc_net_register</tt> automatically uses the <i>/proc/net</i> directory.  They return either 0 (success) or EAGAIN (if there are no available inodes).

</p><p>
      </p><h3><a name="tth_sEc12.3.4">
12.3.4</a>&nbsp;&nbsp;Unregistering a <i>proc</i> Entry</h3>
When an entry is no longer needed, it should be deleted by unregistering it.

<p>
<tt>int proc_unregister(struct proc_dir_entry *dir,int inode)</tt><br>
<tt>int proc_net_unregister(int inode)</tt>

</p><p>
<tt>dir</tt> is the <i>proc</i> directory in which the file resides, and <tt>inode</tt> is the inode number of the file.  (The inode is available in the entry's <tt>struct proc_dir_entry.low_ino</tt> field if it is not a constant.)  Again, these functions are identical except that <tt>proc_net_unregister</tt> automatically uses the <i>/proc/net</i> directory.  They return either 0 (success) or EINVAL (if there is no such entry).

</p><p>
        </p><h2><a name="tth_sEc12.4">
12.4</a>&nbsp;&nbsp;Example</h2>
This is a complete example of a module that installs a simple <i>proc</i> entry.

<p>
<i>simple_entry.c</i>

</p><pre>/* simple_entry.c
 *
 * This program provides an example of how to install an entry into the
 *   /proc File System.  All this entry does is display some statistical
 *   information about IP.
 */

#define MODULE
#include &lt;linux/module.h&gt;
/* proc_fs.h contains proc_dir_entry and register/unregister prototypes */
#include &lt;linux/proc_fs.h&gt;
/* ip.h contains the ip_statistics variable */
#include &lt;net/ip.h&gt;


/************************************************************ show_ip_stats
 * this function is what the /proc FS will call when anything tries to read
 *   from the file /proc/simple_entry - it puts some of the kernel global
 *   variable ip_statistics's contents into the return buffer */
int show_ip_stats(char *buf,char **start,off_t offset,int len,int unused) {
  len = sprintf(buf,"Some IP Statistics:\nIP Forwarding is ");
  if (ip_statistics.IpForwarding)
    len += sprintf(buf+len,"on\n");
  else
    len += sprintf(buf+len,"off\n");
  len += sprintf(buf+len,"Default TTL:  %lu\n",ip_statistics.IpDefaultTTL);
  len += sprintf(buf+len,"Frag Creates: %lu\n",ip_statistics.IpFragCreates);
  /* this could show more.... */
  return len;
}  /* show_ip_stats */

/**************************************************************** test_entry
 * this structure is a sort of registration form for the /proc FS; it tells
 *   the FS to allocate a dynamic inode, gives the "file" a name, and gives
 *   the address of a function to call when the file is read  */
struct proc_dir_entry test_entry = {
  0,                     /* low_ino - inode number (0 for dynamic)  */
  12,                    /* namelen - length of entry name          */
  "simple_entry",        /* name                                    */
  S_IFREG | S_IRUGO,     /* mode                                    */
  1,                     /* nlinks                                  */
  0,                     /* uid - owner                             */
  0,                     /* gid - group                             */
  0,                     /* size - not used                         */
  NULL,                  /* ops - inode operations (use default)    */
  &amp;show_ip_stats         /* read_proc - address of read function    */
                         /* leave rest blank!                       */
};

/*************************************************************** init_module
 * this function installs the module; it simply registers a directory entry
 *   with the /proc FS  */
int init_module() {
  /* register the function with the proc FS */
  int err = proc_register(&amp;proc_root,&amp;test_entry);
  /* put the registration results in the log */
  if (!err)
    printk("&lt;1&gt; simple_entry: registered with inode %d.\n",
          test_entry.low_ino);
  else
    printk("&lt;1&gt; simple_entry: registration error, code %d.\n",err);
  return err;
}  /* init_module */

/************************************************************ cleanup_module
 * this function removes the module; it simply unregisters the directory
 *   entry from the /proc FS  */
void cleanup_module() {
  /* unregister the function from the proc FS */
  int err = proc_unregister(&amp;proc_root,test_entry.low_ino);
  /* put the unregistration results in the log */
  if (!err)
    printk("&lt;1&gt; simple_entry: unregistered inode %d.\n",
          test_entry.low_ino);
  else
    printk("&lt;1&gt; simple_entry: unregistration error, code %d.\n",err);
}  /* cleanup_module */
</pre>

<p>
This is the <i>Makefile</i>:

</p><pre># Makefile for simple_entry

CC = gcc -I/usr/src/linux/include

CFLAGS = -O2 -D__KERNEL__ -Wall

simple_entry.o: simple_entry.c

install:
	/sbin/insmod simple_entry

remove:
	/sbin/rmmod simple_entry
</pre>

<p>
To use (must be <tt>root</tt>):

</p><pre>root# make
root# make install
root# cat /proc/simple_entry
Some IP Statistics:
IP Forwarding is on
Default TTL:  64
Frag Creates: 0
root# make remove
root# tail /var/log/messages
... kernel: simple_entry: registered with inode 4365.
... kernel: simple_entry: unregistered inode 4365.
</pre>

<p>
      </p><h1><a name="tth_chAp13">
Chapter 13     </a><br>Example - Packet Dropper</h1>
<a name="packet_dropper">
</a>

<p>
This sample experiment inserts a routine into the kernel that 
selectively drops packets to a given host.  It discusses the placement 
of the code, outlines the data from an actual trial, presents a 
lightweight analysis of the results, and includes the code itself.

</p><p>
        </p><h2><a name="tth_sEc13.1">
13.1</a>&nbsp;&nbsp;Overview</h2>
This program is implemented as a module that, while installed, compares 
each outgoing packet's destination address to a given target.  If they 
match, it randomly drops a percentage of those packets.  It does this 
for all IP traffic, no matter where it was generated and what transport 
protocol it uses.  Implementing this requires a modification to the 
kernel (to allow a module access to the transmission functions) and a 
module that takes advantage of that modification.

<p>
        </p><h2><a name="tth_sEc13.2">
13.2</a>&nbsp;&nbsp;Considerations</h2>

<dl compact="compact">
<dt><b>Code Placement</b></dt>
	<dd> This code could be built directly into the kernel or it could be designed as a module:

<ul>

<li>Kernel - this is conceptually much simpler; simply adding some code 
to the kernel is a fairly easy matter.  However, it makes semi-permanent
 changes and takes a long time to debug, since the entire kernel must be
 recompiled, installed, and rebooted for every change.

</li><li>Module - this is much safer and easier since the (super) user 
can install, remove, and debug modules quite painlessly.  However, it 
requires access to the kernel that is not always available - even from a
 module.  The kernel does not always export the variables that a module 
may need to access.  (See the discussion on the <i>ksyms</i> program in Chapter&nbsp;<a href="#module">11</a>.)

</li><li>Both - this is the best method; by performing a few minor 
modifications to the kernel code to export necessary variables and make 
use of a module only if it is loaded, a user can recompile the kernel 
once and then perform tests and experiments with modules.  This still 
has the disadvantage of opening potential security holes on a system, 
but since only the experimenter knows how they are implemented, this is a
 minimal risk.
</li></ul>
<p>
</p></dd><dt><b>Protocol Level</b></dt>
	<dd> This code could be implemented at many levels:

<ul>

<li>Device Driver - this is a possibility since all traffic comes 
through the device.  However, this breaks the layering protocols and 
requires hacking a (presumably) stable hardware driver.

</li><li>Generic Device Functions - this is the best choice, since this 
is the lowest level through which all traffic travels (specifically the <tt>dev_queue_xmit()</tt> and <tt>netif_rx()</tt> functions).  It still violates the protocol layering, but all of the modifications can be made in one section of code.

</li><li>IP Protocol - this is conceptually the right place to insert a 
special function, either in the input, routing, or output routines.  
However, this is unsuitable precisely because there are three different 
routines in the implementation that a packet might go through - <tt>ip_forward()</tt> (forwarded packets), <tt>ip_queue_xmit()</tt> (TCP packets), or <tt>ip_build_xmit()</tt> (UDP packets).  See the coding sections in Chapters&nbsp;<a href="#sending">5</a>&nbsp;and&nbsp;<a href="#forward">7</a>
 to see how these routines interact.  These functions would be a good 
choice for inserting a special-purpose dropper, but not one that affects
 all traffic.

</li><li>Transport Protocol - these routines would be appropriate for 
affecting specific traffic types (such as UDP only) but are not useful 
for this example.
</li></ul>
<p>
</p></dd></dl>        <h2><a name="tth_sEc13.3">
13.3</a>&nbsp;&nbsp;Experimental Systems and Benchmarks</h2>
This example was implemented on two computers that are connected through a single router as shown in Figure&nbsp;<a href="#x_setup">13.1</a>;
 the router runs the modifed kernel and packet dropper module.  In the 
general example, this represents traffic flowing between <tt>neon</tt> and <tt>eagle</tt>, with <tt>dodge/viper</tt> dropping packets for <tt>eagle</tt>.

<p><a name="tth_fIg13.1">
</a> 
<img src="linux-net_files/x_setup.gif" alt="x_setup.gif"><br>

 </p><center>Figure 13.1: Experimental system setup.</center>
<a name="x_setup">
</a>
<p>
</p><p>
The switch is a Cisco Catalyst 2900 set up with Virtual LANs (VLANs) for
 each ``subnetwork'' (one for the source computer and one for the 
destination computer, with the routing computer acting as the router 
between the two.  The switch operates entirely on the link level and is 
essentially invisible for routing purposes.

</p><p>
The routing computer (<tt>dodge/viper</tt>) is a Dell Optiplex GX1 with a
 Pentium II/350 processor and 128M of RAM.  It has three 3Com 3c59x 
Ethernet cards with 10Mbps connections to the switch.

</p><p>
One host computer (<tt>neon</tt>) is an AST Premmia GX with a 
Pentium/100 processor and 32M of RAM.  It has an AMD Lance Ethernet card
 with a 10Mbps connection to the switch.

</p><p>
The other host computer (<tt>eagle</tt>) is a Dell Optiplex XL590 with a
 Pentium/90 processor and 32M of RAM.  It has a 3Com 3c509 Ethernet card
 with a 10Mbps connection to the switch.

</p><p>
All computers have the Red Hat 6.1 distribution of Linux; the source and
 destination computers have standard recompiled version 2.2.14 kernels, 
while the router uses either a standard (2.2.14) kernel or a slightly 
modified one as indicated.

</p><p>
The first benchmark is a ``ping-pong'' test that establishes a TCP 
connection and then repeatedly sends packets back and forth.  It returns
 a total transmission time (from start to finish, not including making 
and closing the connection); dividing the time by the number of 
iterations yields an average Round Trip Time (RTT).  This test was run 
with 20,000 iterations of 5 byte packets and 5,000 iterations of 500 
byte packets.

</p><p>
The second benchmark is a ``blast'' test that establishes a TCP 
connection and then sends data from a source to a destination.  It 
returns a total transmission time (from start to finish, not including 
making and closing the connection); multiplying the number of packets by
 the size of the packets and dividing by the time yields the throughput.
  This test was run with 50,000 5 byte packets, 5,000 500 byte packets, 
and 1,000 1500 byte packets.

</p><p>
The benchmarks were run on both machines (i.e., from <tt>neon</tt> to <tt>eagle</tt> and from <tt>eagle</tt> to <tt>neon</tt>), but in both cases only packets to <tt>eagle</tt>
 were dropped.  In each trial the blast test was run once with default 
settings (100 packets of 1 byte each) before running the performance 
tests ``for record'' to ensure that the routing cache and any protocol 
tables were in a normalized state.  The complete suite was run ten times
 to capture variations between trials (the averages are presented here).
  None of the machines (including the router) were running any other 
user programs beyond a login shell and the appropriate module, client, 
or server programs (not even X Windows).

</p><p>
        </p><h2><a name="tth_sEc13.4">
13.4</a>&nbsp;&nbsp;Results and Preliminary Analysis</h2>

<p>
      </p><h3><a name="tth_sEc13.4.1">
13.4.1</a>&nbsp;&nbsp;Standard Kernel</h3>
These are the reference standards; these routines were run with the two 
computers directly connected (NOT routed) and while the router had an 
unmodified Linux 2.2.14 kernel.  The error rate on such a direct 
connection is near zero.

<p>
<i>ping-pong</i>

</p><pre>                           Mean Time (sec)     Average RTT (millisec)
               Drop Rate   20K@5    5K@500         20K@5    5K@500
Direct -
 neon to eagle:   ---      17.24     28.98          0.86     5.80
 eagle to neon:   ---      17.20     28.99          0.86     5.80
Routed -
 neon to eagle:  (0.0%)    24.53     48.59          1.23     9.72
 eagle to neon:  (0.0%)    24.36     48.46          1.22     9.69
</pre>

<p>
<i>blast</i>

</p><pre>                               Mean Time (sec)       Throughput (Mbits/sec)
               Drop Rate   50K*5  10K*500  1K*1500   50K*5  10K*500  1K*1500
Direct -
 neon to eagle:   ---       0.56    3.19     1.89     3.55    6.26    6.36
 eagle to neon:   ---       0.78    3.03     1.77     2.58    6.61    6.76
Routed -
 neon to eagle:  (0.0%)     0.56    3.19     1.92     3.60    6.27    6.26
 eagle to neon:  (0.0%)     0.77    3.19     1.93     2.60    6.27    6.23
</pre>

<p>
      </p><h3><a name="tth_sEc13.4.2">
13.4.2</a>&nbsp;&nbsp;Modified Kernel Dropping Packets</h3>
These are the experimental results.  The drop rate of 0.0% provides a 
reference for measuring the overhead of calling the test and random 
functions without dropping any packets.

<p>
<i>ping-pong</i>

</p><pre>                           Mean Time (sec)     Average RTT (millisec)
               Drop Rate   20K@5    5K@500         20K@5    5K@500
neon to eagle:    0.0%     25.55     49.12          1.28     9.82
                  0.1%     29.87     51.11          1.49    10.22
                  0.5%     44.78     58.07          2.24    11.61
                  1.0%     65.37     68.77          3.27    13.75
                  5.0%    245.51    160.09         12.28    32.02
                 10.0%    506.03    290.77         25.30    58.15
eagle to neon:    0.0%     25.53     49.21          1.28     9.84
                  0.1%     29.08     50.92          1.45    10.18
                  0.5%     45.87     59.21          2.29    11.84
                  1.0%     66.19     68.66          3.31    13.73
                  5.0%    235.68    156.94         11.78    31.39
                 10.0%    519.61    297.02         25.98    59.40
</pre>

<p>
<i>blast</i>

</p><pre>                               Mean Time (sec)       Throughput (Mbits/sec)
               Drop Rate   50K*5  10K*500  1K*1500   50K*5  10K*500  1K*1500
neon to eagle:    0.0%      0.55    3.19     1.91     3.64    6.26    6.27
                  0.1%      0.55    3.07     1.93     3.62    6.51    6.21
                  0.5%      0.55    2.95     1.76     3.64    6.77    6.82
                  1.0%      0.55    2.87     1.75     3.65    6.96    6.87
                  2.5%      0.59    3.36     2.04     3.38    5.59    5.90
                  5.0%      0.63    4.63     2.71     3.19    4.31    4.43
                 10.0%      1.06    7.08     5.11     1.89    2.83    2.35
                 20.0%      3.43   30.35    18.55     0.58    0.66    0.65
eagle to neon:    0.0%      0.79    3.21     1.93     2.53    6.23    6.23
                  0.1%      0.77    3.22     1.89     2.59    6.20    6.35
                  0.5%      0.80    3.24     1.88     2.51    6.17    6.39
                  1.0%      0.77    3.24     1.91     2.60    6.17    6.27
                  2.5%      0.79    3.17     1.90     2.53    6.31    6.33
                  5.0%      0.78    3.17     1.91     2.57    6.31    6.29
                 10.0%      0.81    3.85     2.51     2.48    5.20    4.78
                 20.0%      2.02    4.06     2.51     0.99    4.92    4.78
</pre>

<p>
      </p><h3><a name="tth_sEc13.4.3">
13.4.3</a>&nbsp;&nbsp;Preliminary Analysis</h3>
What follows is an elementary examination of the results.  It is NOT 
intended as an exhaustive analysis, and indeed the experiment was not 
extensive enough to provide hard data from which to draw definite 
conclusions.  However, this does demonstrate the multitude of factors 
involved and the effects that a few lines of code can have on a network.
  Further analysis, if desired, is left as an exercise for the reader.

<p>

</p><p><a name="tth_fIg13.2">
</a> <img src="linux-net_files/x_pong.gif" alt="x_pong.gif"><br> </p><center>Figure 13.2: Ping-pong benchmark results.</center>
<a name="x_pong">
</a>
<p>
</p><p>

</p><p><a name="tth_fIg13.3">
</a> <img src="linux-net_files/x_blast.gif" alt="x_blast.gif"><br> </p><center>Figure 13.3: Blast benchmark results.</center>
<a name="x_blast">
</a>
<p>
</p><p>
The kernel modifications and module insertion had a small but measurable
 impact on a TCP connection (measured by the increased RTT).  For very 
small packets, this difference was approximately 0.05&nbsp;msec; for 
large packets it was 0.10&nbsp;msec.  Why should there be a difference? 
 Note that the direction of travel and packet size made a large 
difference on the throughput.  This is an indication that processor 
speed and layering overhead are affecting the RTT; for a 1500 byte 
packet, 66 bytes of wrappers (20 for TCP, 20 for IP, and at least 26 for
 Ethernet) are not very significant - but for a 5 byte packet, that 
overhead is very large.  Assume that the actual ``cost'' of inserting 
the module the delay for the larger packets, 0.10&nbsp;msec.

</p><p>
Dropping packets from a TCP connection resulted in a fairly linear drop 
in performance on the ping-pong test; see the graph in Figure&nbsp;<a href="#x_pong">13.2</a>.
  This is as expected; when either a packet or acknowledgement is lost, 
the sender pauses and then sends again.  The RTT is also very close 
(certainly within the expected experimental error) no matter which 
machine is the ``source''; again this is because the benchmark tests the
 behavior of both machines at the same time.

</p><p>
At low packet sizes, the throughput was very different depending on which way data was sent.  This is because one machine (<tt>eagle</tt>)
 was slower than the other.  For a large number of very small packets, 
the chokepoint in the network is not the medium or the interface, but 
the speed at which the processor can build and send packets.  However, 
for larger packet sizes, the throughput (for low error rate) for both 
sources is similar; in this case the network is the limiting factor, not
 the processor.

</p><p>
The most surprising result is the apparent peak in throughput when the 
loss rate is approximately 1%  - better even than no loss at all (for 
blasted data; loss of ACKs sent from the receiver to the source had 
little impact).  This is a very counter-intuitive finding; why should 
losing packets speed up the throughput?   A 1% error might be just 
enough to prevent a TCP exponential back-off algorithm from slowing the 
traffic rate.  The immediate ACK that the receiver sends when an 
out-of-sequence packet arrives might include window size information 
that keeps the sender from pausing.  Interrupts caused by 
out-of-sequence packets might result in the scheduler running the 
benchmark process more frequently, emptying the buffer window and again 
keeping the sender from pausing. There are many potential causes; 
determining the real one would take much more study - but would be very 
interesting.

</p><p>
        </p><h2><a name="tth_sEc13.5">
13.5</a>&nbsp;&nbsp;Code</h2>

<p>
      </p><h3><a name="tth_sEc13.5.1">
13.5.1</a>&nbsp;&nbsp;Kernel</h3>
The following code adds a trapdoor to the kernel.  It creates a function that will be called (if it exists) from within the <tt>dev_queue_xmit()</tt>
 function and exports it so that modules will be able to use it.  These 
lines are added directly to the source code; the kernel then has to be 
recompiled. installed, and booted.  Note that the kernel still functions
 normally (albeit with one extra comparison) while no test module is 
installed.

<p>
<i>net/core/dev.c</i> (after line 579)

</p><pre>...
int *test_function(struct sk_buff *)=0;                  /* new */

int dev_queue_xmit(struct sk_buff *skb)...

    ...struct Qdisc  *q;

    if (test_function &amp;&amp; (*test_function)(skb)) {        /* new */
        kfree_skb(skb);                                  /* new */
        return 0;                                        /* new */
    }                                                    /* new */

#ifdef CONFIG_NET_PROFILE...
</pre>

<p>
<i>net/netsyms.c</i> (after line 544)

</p><pre>...
extern int (*test_function)(struct sk_buff *);           /* new */
EXPORT_SYMBOL_NOVERS(test_function);                     /* new */
EXPORT_SYMBOL(register_gifconf);...
</pre>

<p>
      </p><h3><a name="tth_sEc13.5.2">
13.5.2</a>&nbsp;&nbsp;Module</h3>
The following is the code for the packet dropping module itself.  On 
installation, it calculates a percentage cut-off and puts an address 
into the function pointer defined above.  From then on, any packets sent
 through <tt>dev_queue_xmit()</tt> will also pass through the <tt>packet_dropper</tt>
 function, which compares the destination address to a hard coded one.  
If they match and a random number comes up below the calculated cut-off,
 it drops the packet; otherwise the packets pass through untouched.  
When the module is removed, it resets the function pointer to 0 (<tt>null</tt>) again.  (Note that this not very robust code depends on two byte short integers for simplicity.   The function <tt>get_random_bytes()</tt>
 is only accessible to the kernel - or modules, of course - and provides
 random numbers that are ``merely cryptographically strong''.)

<p>
<i>packet_dropper.c</i>

</p><pre>/* packet_dropper.c
 *
 * This program provides an example of how to install a module into a
 *   slightly modified kernel that will randomly drop packets for a specific
 *   (hard-coded) host.
 *
 * See linux/drivers/char/random.c for details of get_random_bytes().
 *
 * Usage (must be root to use):
 *   /sbin/insmod packet_dropper
 *   /sbin/rmmod packet_dropper
 */

#define MODULE
#define MAX_UNSIGNED_SHORT 65535

#include &lt;linux/module.h&gt;
#include &lt;linux/skbuff.h&gt;  /* for struct sk_buff */
#include &lt;linux/ip.h&gt;      /* for struct iphdr */

extern int (*test_function)(struct sk_buff *);       /* calling function */
extern void get_random_bytes(void *buf, int nbytes); /* random function */
unsigned short cutoff;                               /* drop cutoff */
float rate   = 0.050;                                /* drop percentage */
__u32 target = 0x220010AC;                           /* 172.16.0.34 */

/************************************************************ packet_dropper
 * this is what dev_queue_xmit will call while this module is installed */
int packet_dropper(struct sk_buff *skb) {
  unsigned short t;
  if (skb-&gt;nh.iph-&gt;daddr == target) {
    get_random_bytes(&amp;t,2);
    if (t &lt;= cutoff) return 1;    /* drop this packet */
  }
  return 0;                       /* continue with normal routine */
}  /* packet_dropper */

/*************************************************************** init_module
 * this function replaces the null pointer with a real one */
int init_module() {
  EXPORT_NO_SYMBOLS;
  cutoff = rate * MAX_UNSIGNED_SHORT;
  test_function = packet_dropper;
  printk("&lt;1&gt; packet_dropper: now dropping packets\n");
  return 0;
}  /* init_module */

/************************************************************ cleanup_module
 * this function resets the function pointer back to null */
void cleanup_module() {
  test_function = 0;
  printk("&lt;1&gt; packet_dropper: uninstalled\n");
}  /* cleanup_module */
</pre>

<p>
      </p><h1><a name="tth_chAp14">
Chapter 14     </a><br>Additional Resources</h1>
<a name="resources">
</a>

<p>
        </p><h2><a name="tth_sEc14.1">
14.1</a>&nbsp;&nbsp;Internet Sites</h2>

<dl compact="compact">
<dt><b>Linux Documentation Project</b></dt>
	<dd> http://metalab.unc.edu/mdw/index.html
</dd><dt><b>Linux Headquarters</b></dt>
	<dd> http://www.linuxhq.com
</dd><dt><b>Linux HOWTOs</b></dt>
	<dd> ftp://metalab.unc.edu/pub/Linux/docs/HOWTO
</dd><dt><b>Linux Kernel Hackers' Guide</b></dt>
	<dd> http://metalab.unc.edu/mdw/LDP/khg/HyperNews/get/khg.html
</dd><dt><b>Linux Router Project</b></dt>
	<dd> http://www.linuxrouter.org
</dd><dt><b>New TTCP</b></dt>
	<dd> http://users.leo.org/<tt>~</tt>bartel
</dd><dt><b>Red Hat Software</b></dt>
	<dd> http://www.redhat.com
</dd><dt><b>Requests for Comment</b></dt>
	<dd> http://www.rfc-editor.org/isi.html
</dd></dl>
<p>
        </p><h2><a name="tth_sEc14.2">
14.2</a>&nbsp;&nbsp;Books</h2>

<dl compact="compact">
<dt><b>Computer Networks</b></dt>
	<dd> Tanenbaum, Andrew, Prentice-Hall Inc., Upper Saddle River, NJ, 1996.
</dd><dt><b>High Speed Networks</b></dt>
	<dd> Stallings, William, Prentice-Hall Inc., Upper Saddle River, NJ, 1998.
</dd><dt><b>Linux Core Kernel Commentary</b></dt>
	<dd> Maxwell, Scott, CoriolisOpen Press, Scottsdale, AZ, 1999.
</dd><dt><b>Linux Device Drivers</b></dt>
	<dd> Rubini, Alessandro, O'Reilly &amp; Associates, Inc., Sebastopol, CA, 1998.
</dd><dt><b>Linux Kernel Internals</b></dt>
	<dd> Beck, Michael, et al., Addison-Wesley, Harlow, England, 1997.
</dd><dt><b>Running Linux</b></dt>
	<dd> Welsh, Matt, Dalheimer, Matthias, and Kaufman, Lar, O'Reilly &amp; Associates, Inc., Sebastopol, CA, 1999.
</dd><dt><b>Unix Network Programming, Vol. 1 (2d Ed.)</b></dt>
	<dd> Stevens, W. Richard, Prentice-Hall Inc., Upper Saddle River, NJ, 1998.
</dd></dl>
<p>
      </p><h1><a name="tth_chAp15">
Chapter 15     </a><br>Acronyms</h1>
<a name="acronyms">
</a>

<p>

</p><dl compact="compact"><dt><b>ARP</b></dt>
	<dd> Address Resolution Protocol
</dd><dt><b>ATM</b></dt>
	<dd> Asynchronous Transfer Mode (a protocol)
</dd><dt><b>BSD</b></dt>
	<dd> Berkeley Software Distribution
</dd><dt><b>DHCP</b></dt>
	<dd> Dynamic Hardware Configuration Protocol
</dd><dt><b>DNS</b></dt>
	<dd> Domain Name Server
</dd><dt><b>FIB</b></dt>
	<dd> Forwarding Information Base
</dd><dt><b>GUI</b></dt>
	<dd> Graphical User Interface
</dd><dt><b>ICMP</b></dt>
	<dd> Internet Control Message Protocol
</dd><dt><b>INET</b></dt>
	<dd> Internet
</dd><dt><b>IP</b></dt>
	<dd> Internet Protocol
</dd><dt><b>ISP</b></dt>
	<dd> Internet Service Provider
</dd><dt><b>LAN</b></dt>
	<dd> Local Area Network
</dd><dt><b>LDP</b></dt>
	<dd> Linux Documentation Project
</dd><dt><b>lo</b></dt>
	<dd> Loopback (device or interface)
</dd><dt><b>MTU</b></dt>
	<dd> Maximum Transfer Unit
</dd><dt><b>PPP</b></dt>
	<dd> Point-to-Point Protocol
</dd><dt><b>RARP</b></dt>
	<dd> Reverse Address Resolution Protocol
</dd><dt><b>RIP</b></dt>
	<dd> Routing Information Protocol
</dd><dt><b>RTT</b></dt>
	<dd> Round Trip Time
</dd><dt><b>TCP</b></dt>
	<dd> Transmission Control Protocol
</dd><dt><b>UDP</b></dt>
	<dd> User Datagram Protocol
</dd><dt><b>UNH</b></dt>
	<dd> University of New Hampshire
</dd><dt><b>VLAN</b></dt>
	<dd> Virtual Local Area Network
</dd><dt><b>WAN</b></dt>
	<dd> Wide Area Network
</dd></dl>
<p>

</p><p></p><hr><small>File translated from
T<sub><font size="-1">E</font></sub>X
by <a href="http://hutchinson.belmont.ma.us/tth/">
T<sub><font size="-1">T</font></sub>H</a>,
version 2.70.<br>On 31 May 2000, 23:35.</small>

</body></html>